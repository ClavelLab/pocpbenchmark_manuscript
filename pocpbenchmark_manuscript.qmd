---
title: Clear and fast genome-based delineation of bacterial genera
affiliations:
  - id: uka
    name: University Hospital of RWTH Aachen
    department: Institute of Medical Microbiology
    group: Functional Microbiome Research Group
    country: Germany
    url: https://ror.org/02gm5zw39
authors:
  - name: Charlie Pauvert
    corresponding: true
    orcid: 0000-0001-9832-2507
    email: cpauvert@ukaachen.de
    affiliations:
      - ref: uka
    roles:
      - Conceptualization
      - Formal analysis
      - Investigation
      - Software
      - Visualization
      - Writing - original draft
      - Writing - review & editing
  - name: Thomas C.A. Hitch
    orcid: 0000-0003-2244-7412
    affiliations:
      - ref: uka
    roles:
      - Conceptualization
      - Supervision
      - Visualization
      - Writing - review & editing
  - name: Thomas Clavel
    orcid: 0000-0002-7229-5595
    affiliations:
      - ref: uka
    roles:
      - Funding acquisition
      - Resources
      - Writing - review & editing
license: "CC BY"
bibliography: references.bib
crossref:
  custom:
    - kind: float
      key: suppfig
      latex-env: suppfig
      reference-prefix: Figure S
      space-before-numbering: false
      latex-list-of-description: Supplementary Figure
---

```{r setup}
library(tidyverse)
library(targets)
library(cowplot)
```


# Introduction

In the last three years only, the number of bacterial genomes in the RefSeq collection has increased by 35 000 yearly, both from isolates and metagenomes [@haftRefSeqProkaryoticGenome2024]. To analyse these genomes, we need clear and quick methods to taxonomically assign genomes.
For species, Average Nucleotide Identity [ANI, @jainHighThroughputANI2018] has been developed and shown to delineate species almost unanimously [@parksCompleteDomainspeciesTaxonomy2020].
However, ANI is unable to delineate genera [@qinProposedGenusBoundary2014].
While no single ANI threshold has been proposed for genus delineation, family-specific thresholds have been suggested using both the ANI value and alignment fraction, however the lack of a universal threshold limits their usability [@barcoGenusDefinitionBacteria2020].
An alternative to ANI is the Average Amino acid Identity (AAI) which uses protein sequences instead of genomic nucleic sequences [@konstantinidisGenomeBasedTaxonomyProkaryotes2005].
A genus delineation threshold was proposed based on AAI [@konstantinidisUncultivatedMicrobesNeed2017], but this approach is seldom applied [@dieckmannEDGAR3ComparativeGenomics2021; @kimIntroducingEzAAIPipeline2021; @medlarAAIprofilerFastProteomewide2018].
Another protein sequence-based genus delineation method was proposed with an interpretable metric: the Percentage of Conserved Proteins (POCP) [@qinProposedGenusBoundary2014].
If two bacterial entities share more than half of their conserved proteins, i.e., POCP > 50%, they belong to the same genus.

POCP is widely used within the community to assign novel bacterial taxa to known genera, or support the proposal of novel genera [@afrizalEnhancedCulturedDiversity2022; @chaplinHydrogeniiclostidiumMannosilyticumGen2020; @gonzalezAcidiferrimicrobiumAustraleGen2020; @hitchBroadDiversityHuman2024; @wylensekCollectionBacterialIsolates2020]
A major limitation of POCP is that the comparison of all proteins within each genome to each other is computationally demanding.
Given that the number of valid genus names has nearly doubled (@suppfig-lpsn) since the original proposition of POCP by @qinProposedGenusBoundary2014, scalable methods as well as a timely reevaluation of the POCP is required.


@hernandez-salmeronProgressQuicklyFinding2020 compared proteins alignment tools to find faster alternatives, without a loss in precision, showing that DIAMOND [@buchfinkSensitiveProteinAlignments2021], when switched to sensitive parameters instead of defaults, correctly found 87% of the reciprocal best hits of BLASTP [@camachoBLASTArchitectureApplications2009] in less than 8% of the time.
Recently, @holzerPOCPnfAutomaticNextflow2024 suggested the use of DIAMOND with ultra-sensitive settings to compute POCP faster than with BLASTP. His approach is based on previously available script [@holzerHoelzerPocp2020], implemented as a nextflow workflow [@holzerPOCPnfAutomaticNextflow2024]. However, his comparisons are based on limited set of 5 genera, each ranging from 15 to 167 genomes. 
However, the current implementations of POCP available as tools assume conserved proteins have unique matches [@holzerHoelzerPocp2020; @holzerPOCPnfAutomaticNextflow2024;@riescoUpdateProposedMinimal2024;@linSilentGeneBiopyBiopy2021], differing from the original implementation of POCP which had no such limitation [@qinProposedGenusBoundary2014].
We need a clear definition of POCP to clarify the process and ensure repeatability.


To achieve this, we aimed to identify a scalable alternative to BLASTP to compute POCP. Whilst fast and scalable, this alternative should not compromise the accuracy of the original approach.
Second, as POCP provides an interpretable and used metric that can delineate bacterial genera, we will evaluate the ability of POCP to correctly delineate bacterial genera using the optimized implementation.
Based on these findings, we hope to provide microbiologists with a best-practice tool they can confidently use in their workflow to determine the genus assignment of a genome.

::: {#suppfig-lpsn}

```{r suppfiglpsn}
knitr::include_graphics(tar_read(fig_lpsn_stats_png))
```

Cumulative number of validly published genera names according to the International Code of Nomenclature of Prokaryotes (ICNP). The year 2014 is highlighted as it corresponds to the year of publication of the paper by Qin et al. (doi: 10.1128/JB.01688-14) describing the Percentage of Conserved Proteins (POCP) to delineate genus. The number of valid genera is highlighted ten years later. The data was accessed on 2024-12-11 at the List of Prokaryotic names with Standing in Nomenclature [@parteListProkaryoticNames2020].
:::



# Methods

## Standardisation of protein sequences and taxonomy via GTDB

The Genome Taxonomy DataBase (GTDB) provides curated taxonomy along with genomes and genome-derived proteins sequences [@parksGTDBOngoingCensus2022].
We devised a set of inclusion criteria to facilitate inclusion of a diverse range of taxonomic groups, while maintaining achievable comparisons with the time, human and computing resources available.

The criteria for study of a bacterial entry within the GTDB (r214) was: (1) the bacteria has a valid name according to the LPSN, (2) the entry is a representative genome, (3) the bacteria belongs to a family with at least two genera, and (5) it belongs to a genus with at least ten genomes. Based on these criteria, the protein sequence files for the shortlisted bacteria were obtained from GTDB.


```{r funnel}
funnel <- c(
  "GTDB_Genomes" = 394932,
  "Representatives" = 80789,
  "Valid_names" = 11699,
  "More_10_species_per_genus" = 5904,
  "More_1_genus_per_family" = 4767
)
funnel_text <- funnel %>% prettyNum(big.mark=",") %>% as.list() %>% 
  glue::glue_data(
    "Out of a total of {GTDB_Genomes} GTDB bacterial genomes",
    "{Representatives} are representative genomes",
    "{Valid_names} have valid names",
    "{More_10_species_per_genus} belongs to a genus with at least ten genomes",
    "and {More_1_genus_per_family} belongs to a family with at least two genera", .sep = ", "
    )
```

`r funnel_text`.

The bacterial phylogenetic tree of the shortlisted genomes was constructed by trimming the bacterial tree released by GTDB using custom Python scripts and the ETE3 library [@huerta-cepasETEReconstructionAnalysis2016].



## Definition of Percentage of Conserved Proteins (POCP)

The percentage of conserved proteins (POCP) between two genomes $Q$ and $S$ is defined as:

$$
POCP = \dfrac{C_{QS} + C_{SQ}}{T_Q + T_S} \times 100\%
$$ {#eq-pocp}

where $C_{QS}$ represent the conserved number of proteins from $Q$ when aligned to $S$ and conversely $C_{SQ}$ represent the conserved number of proteins from $S$ when aligned to $Q$, and $T_Q + T_S$ represent the total number of proteins in the two genomes being compared, respectively [adapted from @qinProposedGenusBoundary2014].
The range of POCP is theoretically $\left[0;100\%\right]$.
Conserved proteins are defined as protein sequences matches from the query with an e-value < $10^{âˆ’5}$, a sequence identity > 40%, and an aligned region > 50% of the query protein sequence length.

Pairwise comparisons between a query sequence ($Q$) and a subject sequence ($S$) were defined by banning self-comparisons ($Q \neq S$) and considering reciprocal comparisons ($Q\text{-}S$ and $S\text{-}Q$) only within the same family to prevent exponential explosion.


## Approaches for proteins sequence alignment benchmark

In @qinProposedGenusBoundary2014, guidance was provided on how to implement the computation of POCP, including the use of BLASTP, as implemented in Protologger [@hitchAutomatedAnalysisGenomic2021].
As our 'standard' POCP implementation, we used BLASTP v2.14.0+ [@camachoBLASTArchitectureApplications2009] with parameters from @qinProposedGenusBoundary2014 (@tbl-tools-parameters).
We also considered a modified implementation of the BLASTP approach, named BLASTPDB where BLAST databases are first built for the two genomes considered (@tbl-tools-parameters).
This allow parallel alignments on multiple CPU, which is not possible with BLASTP.
We then included two tools that were designed as faster local-protein-alignment approaches and used as alternatives to BLASTP: DIAMOND v2.1.6 [@buchfinkSensitiveProteinAlignments2021] and MMseqs2 v15.6f452 [@steineggerMMseqs2EnablesSensitive2017].
The former is used in @holzerPOCPnfAutomaticNextflow2024 while the latter is used in EzAAI [@kimIntroducingEzAAIPipeline2021].
Similarly to BLASTPDB, these approaches require that a protein database is built for each genome before performing the alignment (@tbl-tools-parameters).
DIAMOND and MMseqs2 were both used with four different sensitivity thresholds (@tbl-tools-parameters) based on a recent comparisons [@buchfinkSensitiveProteinAlignments2021].

```{r tbl-tools-parameters}
#| tbl-cap: "List of the ten approaches and associated parameters for the many-versus-many proteins alignments tools used in the benchmark. The recommended approach is indicated in bold."
tibble::tribble(
  ~Name, ~Parameters,
  "BLAST_BLASTP","--evalue 0.00001 --qcov_hsp_perc 50.0",
  "BLAST_BLASTPDB","--evalue 0.00001 --qcov_hsp_perc 50.0",
  "DIAMOND_FAST","--evalue 0.00001 --query-cover 50.0 --fast",
  "DIAMOND_SENSITIVE","--evalue 0.00001 --query-cover 50.0 --sensitive",
  "DIAMOND_VERYSENSITIVE","--evalue 0.00001 --query-cover 50.0 --very-sensitive",
  "DIAMOND_ULTRASENSITIVE","--evalue 0.00001 --query-cover 50.0 --ultra-sensitive",
  "MMSEQS2_S1DOT0","--e-profile 0.00001 --cov-mode 1 -c 0.50 -s 1.0",
  "MMSEQS2_S2DOT5","--e-profile 0.00001 --cov-mode 1 -c 0.50 -s 2.5",
  "MMSEQS2_S6DOT0","--e-profile 0.00001 --cov-mode 1 -c 0.50 -s 6.0",
  "MMSEQS2_S7DOT5","--e-profile 0.00001 --cov-mode 1 -c 0.50 -s 7.5"
) %>% 
  mutate(
    Name = if_else(Name=="DIAMOND_VERYSENSITIVE", "**DIAMOND_VERYSENSITIVE**", Name),
    `Database creation` = if_else(Name == "BLAST_BLASTP", "No", "Yes"),
    Parameters = glue::glue("`{p}`", p=Parameters)
    ) %>%
  rename("Approach name"="Name") %>% 
  select(`Approach name`, `Database creation`, Parameters) %>% knitr::kable()
```

All proteins matches were filtered to only keep matches with > 40 % identity to all the query sequences matches for POCP ($C_{QS}$ and $C_{SQ}$ in @eq-pocp) and only unique query sequence matches for POCPu ($C_{QS}$ and $C_{SQ}$ in @eq-pocpu).
Note that the filtering was adapted to the method as the range of percentage of identity in MMseqs2 is $[0-1]$ and $[0-100]$ for BLAST and DIAMOND.
The total number of proteins per genomes ($T_Q$ and $T_S$ in @eq-pocp and @eq-pocpu) was computed using seqkit stats v2.2.0 [@shenSeqKitCrossPlatformUltrafast2016].

Linear regressions were implemented using `r R.version.string` to fit the expected POCP (or POCPu) values obtained via the legacy BLAST_BLASTP approach against the others approaches considered.
The coefficient of determination R^2^ of the linear regression is used as an interpretable and bounded goodness-of-fit measure between the expected and measured values instead of others errors measurement [@chiccoCoefficientDeterminationRsquared2021].
We did not rely on the adjusted coefficient of determination as the linear regressions had only one predictor, namely the POCP (or POCPu) values of the evaluated approach.


## Metrics to evaluate genus delineation

We computed classification metrics with a positive event defined as "both genomes belong to the same genus".
Thus, for a pair of bacterial genomes with a POCP (or POCPu) > 50%, the pair is a True Positive ($TP$) if the pair belong to the same genus, or if not to False Positive ($FP$).
Conversely, for a pair of bacterial genomes with a POCP (or POCPu) $\leq$ 50%, the pair is a False Negative ($FN$) if the pair belong to the same genus, or if not to True Negative ($TN$).
We assess the classification performance of both POCP and POCPu with the Matthews Correlation Coefficient (MCC; @eq-mcc).

$$
MCC = \dfrac{TP \times TN - FP \times FN}{\sqrt{(TP + FP)(TP + FN)(TN + FP)(TN+FN)}}
$$ {#eq-mcc}

The coefficient has a range of $\left[-1;+1\right]$ and is only high in case of perfect classification, as a MCC of 0 indicates a random classification. Plus, the MCC compensates for unequal class sizes compared to others metrics such as accuracy or F1-score [@chiccoAdvantagesMatthewsCorrelation2020].

## Workflow implementation

Automatic protein sequences download, data preprocessing, many-versus-many protein alignments, as well as POCP computation and delineation metrics calculations were within a nextflow v23.10.0 [@ditommasoNextflowEnablesReproducible2017] workflow, using components of nf-core [@ewelsNfcoreFrameworkCommunitycurated2020].
Tools used are provided within Docker container [@merkelDockerLightweightLinux2014] or bioconda [@thebiocondateamBiocondaSustainableComprehensive2018] environments to ensure reproducibility, scalability and ease future extensions of the benchmark.

Nextflow natively keep track of the time, CPU, memory and disk usage of each process in an execution trace log file that we used to evaluate computing resources utilization. Process duration is available as walltime and realtime, the CPU usage is reported as a percentage of usage of a unique CPU, meaning multi-threaded processes will have a value higher than 100%.

Statistical analyses and visualization were conducted within R using targets v.1.7.0 [@landauTargetsPackageDynamic2021].


# Results

## Finding a BLASTP alternative for POCP


First, we set out to identify a scalable alternative to BLASTP to compute the Percentage Of Conserved Proteins (POCP) to delineate genera.
We evaluated ten proteins alignment approaches (@tbl-tools-parameters) based on three tools -- BLASTP [@camachoBLASTArchitectureApplications2009], DIAMOND [@buchfinkSensitiveProteinAlignments2021] and MMseqs2 [@steineggerMMseqs2EnablesSensitive2017].

```{r benchmark_all_text}
phyla_count_text <- tar_read(tree_metadata) %>% filter(benchmark_type=="All approaches") %>% 
  select(Phylum:Species) %>%
  group_by(Phylum) %>%
  summarise(across(everything(),n_distinct)) %>%
  arrange(desc(Species)) %>%
  glue::glue_data(
    "{Phylum} ({Family} families, {Genus} genera, {Species} species)",
    Species = prettyNum(Species, big.mark=",")) %>%
  glue::glue_collapse(sep = ", ", last = " and ")
```


```{r cpu_hours}
stats_by_type <- tar_read(family_metadata) %>%
  select(Family,benchmark_type, n_genomes,CPU_hours) %>%
  group_by(benchmark_type) %>% 
  mutate(
    n_comparisons_planned=n_genomes*(n_genomes-1),
    n_comparisons_realized=if_else(benchmark_type=="full",
                          n_comparisons_planned*10, n_comparisons_planned)
                          ) %>%
  summarise(
    n_families = n(),
    n_genomes = sum(n_genomes),
    n_planned = sum(n_comparisons_planned*10),
    n_realized = sum(n_comparisons_realized),
    total_hours = sum(CPU_hours)
    )
overall_stats <- stats_by_type %>% filter(benchmark_type=="full") %>% 
  summarise(across(!benchmark_type,sum)) %>% 
  mutate(
    total_hours = round(total_hours),
    total_years = as.period(total_hours, unit = "hours") %>% as.numeric("years")
  ) %>% mutate(across(everything(), ~prettyNum(.x,big.mark = ",", digits=2)))
stats_by_type_text <- stats_by_type %>%
  mutate(across(everything(), ~prettyNum(.x,big.mark = ",", digits=2))) %>% 
  glue::glue_data(
    "({n_families} families, {n_genomes} genomes, {n_realized} comparisons)"
    )
```


```{r genomes-in-full}
n_genomes_in_full <- stats_by_type %>% 
  filter(benchmark_type=="full") %>% pull(n_genomes) %>% 
  prettyNum(big.mark = ",")
```


::: {#tbl-tools-metrics}

```{r tools-metrics}
n_processes <- tar_read(tool_table) %>% pull(n) %>% unique() %>% prettyNum(big.mark=",")
tar_read(tool_table) %>% filter(tool!="BLAST_BLASTP") %>%
  select(-n) %>%
  rename("Approach name" = "tool",
         "Time"="time_fold", "Memory"="memory_fold",
         "CPU"="cpu_fold", "Disk usage (I/O)"="io_fold") %>% 
  knitr::kable(digits = 3)
```

Fold change of computing metrics for the 9 approaches used in the benchmark compared to the BLAST_BLASTP approach.
The metrics include processing time as real-time, memory usage, CPU usage and disk usage as input/output (I/O).
A fold change below 1 means the metric is lower, whilst above 1 means it is higher, compared to the BLAST_BLASTP approach.
The fold change values are median computed over $n$ = `r n_processes` number of processes tracked per approach.
:::


To do so, we used GTDB genomes from a wide range of bacterial phylogenetic diversity across four phyla: `r phyla_count_text`. 
We processed these `r n_genomes_in_full` genomes and conducted `r overall_stats$n_realized` pairwise comparisons with a total of `r overall_stats$total_hours` CPU-Hours (`r overall_stats$total_years` in years).
All the approaches tested are faster than our control BLASTP (@tbl-tools-metrics).
BLASTPDB, the database approach to BLASTP (@tbl-tools-parameters) that allows for parallel computations, was only half the time of BLASTP on average, but DIAMOND and MMSEQS2 based approaches were ran in a fraction of the time of BLASTP.
Such speed-up does not come without a price: all approaches are obviously using more memory and more CPU (@tbl-tools-metrics), plus, they also read and write more to the disk. We confirmed, as one would expect, the trend that more sensitive approaches consume more resources in general.

However, a more important criteria for a BLASTP alternative is to evaluate whether the accuracy of the POCP calculation is not sacrificed in the name of computational performance.

### DIAMOND gives POCP as accurate as BLASTP

::: {#suppfig-blastdb}
```{r blastdb}
n_blastdb_comparisons <- tar_read(blast_vs_all_pocpu) %>%
  count(tool) %>% pull(n) %>%
  unique() %>% prettyNum(big.mark=",")
knitr::include_graphics(tar_read(fig_blast_vs_blastdb_png))
```

Adequacy between POCP (A) and POCPu (B) values computed with the legacy BLAST_BLASTP against the BLAST_BLASTPDB approach that build databases before alignment.
Each point ($n$ = `r n_blastdb_comparisons` per tool) represents a POCP/POCPu value between two genomes (see @eq-pocp and @eq-pocpu).
The colors represent the number of data points binned together in hexagons to avoid over-plotting.
Coefficient of determination ($R^2$) and associated $p$-value are shown on top of each linear regressions.
:::



::: {#tbl-R2}

```{r R2}
#| html-table-processing: none
#| classes: plain
library(gt)
tar_load(R2_table)
n_comparisons_in_lm <- unique(R2_table$POCP_nobs) %>% prettyNum(big.mark = ",")
R2_table %>% arrange(desc(POCPu_R2)) %>%
    gt::gt(rowname_col = "tool") %>%
    tab_stubhead("Approach name") %>% cols_align(align = "left", columns = "tool") %>%
    tab_spanner("POCP", starts_with("POCP_")) %>%
    tab_spanner("POCPu", starts_with("POCPu_")) %>% cols_hide(ends_with("_nobs")) %>%
    cols_label(
      POCP_R2 = md("$R^2$"),POCPu_R2 = md("$R^2$"),
      POCP_p_label = md("$p$-value"),POCPu_p_label = md("$p$-value")
    ) %>%
  tab_options(column_labels.font.weight = "bold")
```

Coefficient of determination ($R^2$) and associated $p$-value for linear regressions matching the POCP and POCPu values computed by each approach against the respective POCP and POCPu values of BLAST_BLASTP legacy approach. Each linear regression are based on $n$ = `r n_comparisons_in_lm` comparisons per approach. Approaches are sorted by decreasing POCPu $R^2$ values.
:::

BLASTPDB produced exactly similar POCP values to BLASTP (@suppfig-blastdb A). The other approaches do not perform as well.
All flavors of DIAMOND have a coefficient of determination ($R^2$) above 0.99 when matching their POCP values with the original from BLASTP, with the exception of the DIAMOND_FAST approach that deviates more from the expected values (@fig-blast-vs-all-pocp and @tbl-R2).
This deviation is exacerbated when using the MMSEQS2_S1DOT0 approach, but is somehow rescued with the others MMSEQS2 approaches, though they perform worse than the DIAMOND approaches and should therefore not be used as BLASTP alternatives for POCP.

What happens when POCP values deviate between the alternative and BLASTP?
If the alternative underestimate POCP -- i.e., with values under the dashed line in @fig-blast-vs-all-pocp --, the alternative will split genus and tend to assign genomes to different genera when they are from the same genus.
Conversely, if the alternative overestimate POCP -- i.e., with values over the dashed line in @fig-blast-vs-all-pocp --, the alternative will lump genera together and tend to assign genomes to the same genus when they are not.
DIAMOND approaches show underestimation, especially DIAMOND_FAST, but not overestimation (@fig-blast-vs-all-pocp), whilst MMSEQS2 approaches tend to overestimate more than underestimate, with more deviation altogether.
All in all, DIAMOND-based approaches, especially with increased sensitivity gives POCP as accurate as BLASTP for a fraction of the time.


::: {#fig-blast-vs-all-pocp}

```{r blast_vs_all_pocp}
n_blast_comparisons <- tar_read(blast_vs_all_pocp) %>%
  count(tool) %>% pull(n) %>%
  unique() %>% prettyNum(big.mark=",")
knitr::include_graphics(tar_read(fig_blast_vs_all_pocp_png))
```

Adequacy between POCP values computed with the legacy BLAST_BLASTP against flavors of faster alternatives: DIAMOND [@buchfinkSensitiveProteinAlignments2021] and MMSEQS2 [@steineggerMMseqs2EnablesSensitive2017].
Each point ($n$ = `r n_blast_comparisons` per tool) represents a POCP value between two genomes (see @eq-pocp).
The colors represent the number of data points binned together in hexagons to avoid over-plotting.
Coefficient of determination ($R^2$) and associated $p$-value are shown on top of each linear regressions.
:::

### Towards a clearer POCP definition

Yet, all approaches have POCP values over 100% (@fig-blast-vs-all-pocp). Surprised as we were to see percentages exceed their supposed upper bound, we sought to investigate and eventually suggest a clearer definition of POCP, that we termed POCPu.

During the alignment process, proteins sequences from the query can match multiple subject sequences in the case of duplicated genes.
While briefly mentioned in the original paper that "The number of conserved proteins in each genome of strains being compared was slightly different because of the existence of duplicate genes (paralogs)" [@qinProposedGenusBoundary2014, p. 2211], the expected influence on the POCP values is lacking. Therefore, we defined the POCP with unique matches (POCPu) between two genomes $Q$ and $S$ as:

$$
POCPu = \dfrac{C_{uQS} + C_{uSQ}}{T_Q + T_S} \times 100\%
$$ {#eq-pocpu}

where $C_{uQS}$ represent the conserved number of proteins from *the unique matches of* $Q$ when aligned to $S$ and conversely $C_{uSQ}$ represent the conserved number of proteins from *the unique matches of* $S$ when aligned to $Q$, and $T_Q + T_S$ represent the total number of proteins in the two genomes being compared, respectively.


::: {#fig-blast-vs-all-pocpu}

```{r blast_vs_all_pocpu}
n_blast_comparisons_pocpu <- tar_read(blast_vs_all_pocpu) %>%
  count(tool) %>% pull(n) %>%
  unique() %>% prettyNum(big.mark=",")
knitr::include_graphics(tar_read(fig_blast_vs_all_pocpu_png))
```

Adequacy between POCPu values computed with the legacy BLAST_BLASTP against flavors of faster alternatives: DIAMOND [@buchfinkSensitiveProteinAlignments2021] and MMSEQS2 [@steineggerMMseqs2EnablesSensitive2017].
Each point ($n$ = `r n_blast_comparisons_pocpu` per tool) represents a POCPu value between two genomes (see @eq-pocpu).
The colors represent the number of data points binned together in hexagons to avoid over-plotting.
Coefficient of determination ($R^2$) and associated $p$-value are shown on top of each linear regressions.
:::

These higher-than-100% POCP values disappears when using the POCPu (@fig-blast-vs-all-pocpu and @suppfig-blastdb B).
Otherwise, the same patterns observed for POCP hold for POCPu, though with higher values of coefficient of determination (@fig-blast-vs-all-pocpu and @tbl-R2).
The 3 different sensitive approaches of DIAMOND produce POCPu values that match perfectly the ones produce by the legacy approach BLAST_BLASTP, with no underestimation as in the case of POCP previously.
However, the MMSEQS2 approaches, whilst better with POCPu than POCP, still tend to underestimate POCPu values.
All in all, POCPu is closer to BLASTP than POCP (@fig-blast-vs-all-pocpu) thus guiding our choices to an accurate BLASTP alternative.

The BLAST_BLASTPDB approach is a strong contender for a BLAST_BLASTP alternative because whilst using more resources, it performs exactly the same as BLAST_BLASTP (@suppfig-blastdb and @tbl-R2) in a fraction of the time (@tbl-tools-metrics).
Still, DIAMOND-based sensitive approaches are way faster with excellent adequacy with BLAST_BLASTP approach, especially for POCPu (@tbl-R2).
Whilst DIAMOND_ULTRASENSITIVE would have the highest $R^2$ value using POCPu (@tbl-R2), it has the highest memory consumption and disk usage of the tested approaches (@tbl-tools-metrics).
A more sustainable alternative would be DIAMOND_VERYSENSITIVE that performs 10 times faster than BLAST_BLASTPDB, in less than $1/20^{th}$ of the time of BLAST_BLASTP, while still maintaining reasonable usage of the resources (@tbl-tools-metrics).
More importantly, DIAMOND_VERYSENSITIVE POCPu provides extremely similar results to the legacy approach BLAST_BLASTP (@fig-blast-vs-all-pocpu and @tbl-R2) and is essentially identical to DIAMOND_ULTRASENSITIVE POCPu $R^2$ up to 5 digits (@tbl-R2).
Therefore, we consider DIAMOND_VERYSENSITIVE to be a valid and scalable alternative to BLAST_BLASTP for POCP/POCPu computations.

## Genus delineation with POCP and POCPu

```{r confusion_matrix}
targets::tar_load(c(pocp_confusion,pocpu_confusion))
n_genomes <- sum(stats_by_type$n_genomes) %>% prettyNum(big.mark = ",")
phyla_count_total_text <- tar_read(tree_metadata) %>% 
  select(Phylum:Species) %>%
  group_by(Phylum) %>%
  summarise(across(everything(),n_distinct)) %>%
  arrange(desc(Species)) %>%
  glue::glue_data(
    "{Phylum} ({Family} families, {Genus} genera, {Species} species)",
    Species = prettyNum(Species, big.mark=",")) %>%
  glue::glue_collapse(sep = ", ", last = " and ")
```

### Considering only unique matches enhances genus delineation

Then, we tested the 50%-threshold of POCP and POCPu, and evaluate how useful these metrics are to delineate bacterial genera.
Using additional genomes, this dataset covers even more bacterial phylogenetic diversity: `r phyla_count_total_text`.
We use all the `r n_genomes` genomes and calculate POCP and POCPu with the DIAMOND_VERYSENSITIVE approach (@fig-pocp-pocpu-densities).
Optimistically, we expected two bell-shaped distributions, with the "Between genera" POCPs neatly apart from the "Within genus" POCPs by a gap around 50%.

The two distributions do overlap though (@fig-pocp-pocpu-densities A).
Indeed, POCP yields a high number of false positives (FP = `r pocp_confusion["FP"]`), where the "Between genera" distribution is above 50%, especially compared to the number of true negatives (TN = `r pocp_confusion["TN"]`), where the "Between genera" distribution is below 50%.
Thankfully, most of the "Within genus" distribution of POCP is above 50% (TP = `r pocp_confusion["TP"]`), with fewer below the threshold (FN = `r pocp_confusion["FN"]`).

POCPu is closer to our expectations (@fig-pocp-pocpu-densities B).
"Between genera" POCPu follows a bi-modal distribution, with the highest peak and most of the distribution below the 50% threshold (TN = `r pocpu_confusion["TN"]`).
Still, this distribution spills above the threshold, indicating POCPu also produces false positives (FP = `r pocp_confusion["FP"]`).
Like POCP, "Within genus" POCPu concentrate largely above the threshold of 50% (TP = `r pocpu_confusion["TP"]`), with fewer below the threshold (FN = `r pocpu_confusion["FN"]`).
All in all, we put forward that considering only unique matches enhances genus delineation.


```{r mcc}
mcc_pocp <- targets::tar_read(mcc_pocp_global) %>%
  pull(mcc) %>% prettyNum(digits = 2)
mcc_pocpu <- targets::tar_read(mcc_pocpu_global) %>%
  pull(mcc) %>% prettyNum(digits = 2)
tally_mcc_thresholds <- summarise(
  tar_read(mcc_pocpu_family), 
  total = n(), n_70 = sum(mcc >= 0.7), n_25 = sum(mcc <= 0.25)
)
```

We quantify our findings on the confusion matrix using the  Matthews Correlation Coefficient (@eq-mcc).
MCC is a binary classification rate that gives a high score only when the classifier correctly predicts the majority of positive and negative cases.
Therefore, POCPu (MCC = `r mcc_pocpu`) surpasses POCP (MCC = `r mcc_pocp`) to delineate bacterial genus, which quantitatively confirm our visual findings (@fig-pocp-pocpu-densities).

::: {#fig-pocp-pocpu-densities}

```{r pocp-pocpu-densities}
tar_load(c(pocpu_group_sizes, pocp_range, pocpu_range))
knitr::include_graphics(tar_read(fig_pocp_pocpu_densities_png))
```

Distribution of POCP (A) and POCPu (B) values for all pairwise genome comparisons: `r pocpu_group_sizes[1]` in orange and `r pocpu_group_sizes[2]` in sky blue, both based on GTDB taxonomy.
Contrast these true categories with POCP/POCPu decisions: POCP > 50%, meaning right of the dashed line (A, B) indicates more than half of shared conserved proteins, and hence same genus.
POCP and POCPu values are calculated with the recommended approach DIAMOND_VERYSENSITIVE (@tbl-tools-parameters) and they range from `r pocp_range` and `r pocpu_range`.
:::


::: {#fig-genus-delineation}

```{r genus-delineation}
knitr::include_graphics(tar_read(fig_genus_delineation_png))
```


POCPu delineates bacterial genera in a family-specific manner.
Three representative examples of family-specific genus delineation capacity (A) where POCPu distributions can be neatly distinct and allow for genus delineation (A; _Xanthobacteraceae_), or overlap and hamper genus delineation (A; _Streptomycetaceae_), or any in between scenario (A; _Lactobacillaceae_).
These scenarios can be quantified with the Matthews Correlation Coefficient [MCC, @chiccoAdvantagesMatthewsCorrelation2020]. We show MCC values for each family where MCC of -1 and +1 indicates perfect misclassification and classification, respectively (B). Random genus delineation would give MCC = 0. The dashed line in B indicates the overall MCC when not splitting by family. We also highlight how many $n$ genomes are included per family, and their phyla in the vertical facets (B). The POCPu distributions for all families are drawn in @suppfig-pocpu-by-family.
:::

### Family-specific POCPu thresholds for a clearer delineation


When we consider the bacterial families separately, another pattern emerge (@fig-genus-delineation and @suppfig-pocpu-by-family).
The large family of _Streptomycetaceae_ (Actinomycetota), for instance, exhibits many `r targets::tar_read(streptomycetaceae)`, and consequently has a very low MCC (@fig-genus-delineation A).
We highlight two additional examples that illustrate how MCC well capture the separation of the POCPu distributions, and hence the genus delineation (@fig-genus-delineation A).
In `r tally_mcc_thresholds[["n_25"]]` families out of 35, POCPu is clearly not adequate to delineate genus with low MCC (MCC $\leq$ 0.25; @fig-genus-delineation B).
Not all is lost, as `r tally_mcc_thresholds[["n_70"]]` families out of 35 show that POCPu delineates bacterial genera accurately (MCC $\geq$ 0.7;  @fig-genus-delineation B). For instance, for all the comparisons done within the _Lactobacillaceae_ family (Bacillota), we see `r targets::tar_read(lactobacillaceae)` (@fig-genus-delineation A).
All categories of the confusion matrix vary greatly, which underline the need to a metric that can aggregate these counts without bias, and thus show that while POCPu is not a one-size-fits-all method, it can correctly delineate genera.

```{r}
optimized_pocpu <- tar_read(optimized_pocpu) %>%
  filter(improved_classification) %>%
  mutate(
    rescued = if_else(mcc <0.7 & maximum_mcc>0.7,"rescued","improved"),
    category = if_else(optimized_threshold <= 50, "decrease","increase")
         ) 
n_tentative <- optimized_pocpu %>% count(rescued) %>% deframe()
n_category <- optimized_pocpu %>% count(category) %>% deframe()
n_decrease_family<- optimized_pocpu %>%
  filter(category=="decrease") %>%
  mutate(across(Phylum:Family, ~ str_remove(.x, "[p|f]__"))) %>% 
  glue::glue_data("_{Family}_ ({Phylum})") %>%
  glue::glue_collapse(" and ",last = " families")
```


What is a standard without its exception we asked ourselves, and we looked for family-specific POCPu thresholds by maximizing MCC to improve genus delineation (@suppfig-pocpu-by-family and @tbl-optimized_threshold).
With this procedure, the genus delineation of `r n_tentative[["improved"]]` families was improved, with at least 0.1 point increase in MCC, and for `r n_tentative[["rescued"]]` additional families it was even rescued with a maximum MCC above 0.7.
Overall, for `r sum(n_tentative)` families out of the `r sum(stats_by_type$n_families)` families, thresholds distinct from the default 50% enhance the classification.
Interestingly, in only `r n_category[["decrease"]]` cases, an optimal POCPu threshold had to be lowered: `r n_decrease_family` .
In  `r n_category[["increase"]]` cases, a larger-than-half fraction of conserved proteins better separate genomes from within genus and between genera (@tbl-optimized_threshold).

We even leverage our large dataset to assess claims that POCP is influenced by differences in genome size [@riescoUpdateProposedMinimal2024]. If POCPu is influenced, we reason that its genus delineation power should also be influenced, therefore we expect stronger genome size differences in the families for which an alternative POCPu threshold was found.
We found no convincing patterns to support the claim that differences in genome size (@suppfig-delta A) nor in number of proteins (i.e., proteome; @suppfig-delta B) influenced POCPu.
Overall, POCPu provides a useful and interpretable metric to delineate genera.

::: {#tbl-optimized_threshold}


```{r optimized_threshold}
#| html-table-processing: none
#| classes: plain
library(gt)
tar_read(optimized_pocpu_table)
```


Tentative family-specific POCPu thresholds for genus delineation.
The thresholds were obtained after maximizing the MCC value via optimization.
Ticks indicate that MCC value change was greater than 0.1 with the optimized threshold, and highlights potential family-specific threshold worth considering to replace the default of 50%. Crosses indicate families for which such optimization was deemed unnecessary.
:::


::: {#suppfig-pocpu-by-family}

```{r suppfigpocpu-by-family}
knitr::include_graphics(tar_read(fig_pocpu_by_family_png))
```

Distributions of POCPu values as in @fig-pocp-pocpu-densities broken down per bacterial family. The true category is based on the GTDB taxonomy. Tentative family-specific POCPu thresholds for genus delineation were taken from @tbl-optimized_threshold and are indicated with plain vertical line, else the default POCPu threshold is drawn at 50% with a dashed line.
:::


::: {#suppfig-delta}

```{r suppfigdelta}
knitr::include_graphics(tar_read(fig_delta_proteome_genome_png))
```

Distributions of differences in genome size (A) and proteome size (B) for families using default threshold or optimized thresholds. We expected families using optimized threshold to have a shift in their differences distributions, which would have indicated that genome size and proteome size influence genus delineation. POCPu thresholds type were taken from @tbl-optimized_threshold.
:::

# Discussion

```{r stats_total}
total_stats <- stats_by_type %>% 
  summarise(across(!benchmark_type,sum)) %>% 
  mutate(
    total_hours = round(total_hours),
    total_years = as.period(total_hours, unit = "hours") %>% as.numeric("years")
  ) %>% mutate(across(everything(), ~prettyNum(.x,big.mark = ",", digits=2)))
n_genera <- tar_read(genome_metadata) %>% pull(Genus) %>% n_distinct()
```


Ten years after @qinProposedGenusBoundary2014 suggested to separate bacterial genera using the Percentage of Conserved Proteins (POCP), we set out to reevaluate their claims in this much richer data landscape. 
Using `r total_stats$n_genomes` genomes from `r n_genera` genera and `r total_stats$n_families` families, our infrastructure compared `r total_stats$n_realized` unique pairs of genomes combinations meaning it ran for `r total_stats$total_hours` CPU-Hours (`r total_stats$total_years` in years).
We showed that DIAMOND_VERYSENSITIVE could reliably replace BLASTP for scaled-up POCP computations.
We more specifically addressed an implicit assumption made in POCP implementations [e.g., @holzerHoelzerPocp2020; @holzerPOCPnfAutomaticNextflow2024; @linSilentGeneBiopyBiopy2021], and explicitly defined an alternative POCP metric -- POCPu -- and thus demonstrated that using only unique matches enhances genus delineation.


We acknowledge that our selection of genomes might miss important taxonomical groups to the readers, and that we could have included more taxa as well.
Who chooses has to give up as the saying goes. Indeed, we carefully curated which taxa to include in order to end up with enough data points per taxa to ensure statistically robust patterns in our data-driven approach.
Previous works on many-vs-many proteins alignment comparison used much less phylogenetically strong signals: 4 genomes from 4 genera in @hernandez-salmeronProgressQuicklyFinding2020, maximum 167 genomes from 5 genera in @holzerPOCPnfAutomaticNextflow2024.
@riescoUpdateProposedMinimal2024 evaluated much more genomes -- 1 573 type strains -- but calculated POCP -- using Bio-Py [@linSilentGeneBiopyBiopy2021] -- only to be compared with AAI and not to evaluate genus delineation.
We also relied on the GTDB as our ground truth taxonomy, which is limited to bacteria and also that include non valid names, that we filtered.
Therefore, despite these limitations, our data-driven approach use a wide range of taxa and an extensive number of high-quality genomes to bring forth useful findings for the modern taxonomist. 

In an effort to improve genus delineation, we sought to find optimized thresholds per family.
However, we also believe that one of the strength of the POCP is its interpretability. So, one should only deviate from the straightforward threshold of 50% if the benefits are much greater.
We provided tentative thresholds for a few families where this was the case.


Genus name occurs before species name in the binomial nomenclature, therefore genera are our first contact with the bacterial entities we are studying. These names are key to existing knowledge in  databases or articles and hint already towards their evolutionary histories and ecological roles [@reimerBacDive2022Knowledge2022; @rosonovskiEuropePMC20232024; @schochNCBITaxonomyComprehensive2020]. Therefore, how to assign bacterial genus to a genome is fundamental to ensure the reliability of this knowledge.
Then it was important that we made our findings available as a best-practice tool for microbiologists to delineate genera from genomes: <https://github.com/clavelLab/consprot>.
Especially, we were able to underline that not all set of tools and parameters are suitable to speed up BLASTP. Some combinations, while extremely fast, under- or overestimate POCP which consequently will erroneously split or lump genera respectively.

Threshold-based approaches are always a matter of compromises, where no one-size-fits-all exist. In that regards, @parksGTDBOngoingCensus2022  put it well for the species delineation problem: "The use of ANI to delineate species despite the lack of clear evidence for discrete species boundaries in the GTDB dataset is a pragmatic approach for organizing the rapidly growing biodiversity being discovered with metagenomic approaches".
We share their vision and propose to adopt the POCPu to delineate genera as an interpretable and  pragmatic approach to organize rapidly and transparently this data deluge.


# References

::: {#refs}
:::
