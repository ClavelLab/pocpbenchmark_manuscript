---
title: Clearer, better, faster, reproducible bacterial genus delineation procedure
affiliations:
  - id: uka
    name: University Hospital of RWTH Aachen
    department: Institute of Medical Microbiology
    group: Functional Microbiome Research Group
    country: Germany
    url: https://ror.org/02gm5zw39
authors:
  - name: Charlie Pauvert
    corresponding: true
    orcid: 0000-0001-9832-2507
    email: cpauvert@ukaachen.de
    affiliations:
      - ref: uka
  - name: Thomas C.A. Hitch
    orcid: 0000-0003-2244-7412
    affiliations:
      - ref: uka
  - name: Thomas Clavel
    orcid: 0000-0002-7229-5595
    affiliations:
      - ref: uka
license: "CC BY"
bibliography: references.bib
crossref:
  custom:
    - kind: float
      key: suppfig
      latex-env: suppfig
      reference-prefix: Figure S
      space-before-numbering: false
      latex-list-of-description: Supplementary Figure
---

```{r setup}
library(tidyverse)
library(targets)
library(cowplot)
```


# Introduction

Genus name occurs before species name in the binomial nomenclature, therefore genera are our first contact with the bacterial entities we are studying.
These names open the door to existing knowledge in the form of databases entries [@reimerBacDive2022Knowledge2022; @schochNCBITaxonomyComprehensive2020] and articles [@rosonovskiEuropePMC20232024], and can help us know more about their evolutionary histories and infer ecological roles. With far more bacterial genomes from isolates or metagenomes available than previously possible [@haftRefSeqProkaryoticGenome2024], we need to clearly and quickly identify when two bacterial entities belong to the same genus or different genera, a process termed genus delineation.

Whilst the Average Nucleotide Identity [ANI, @jainHighThroughputANI2018] help delineate species almost unanimously [@parksCompleteDomaintospeciesTaxonomy2020], genus delineation lacks such consensus.
Indeed, no single appropriate ANI threshold were found to separate prokaryotic genera [@qinProposedGenusBoundary2014], but later family-based thresholds delineate genera using ANI plus alignment fraction [@barcoGenusDefinitionBacteria2020].
Protein sequences replaced nucleic sequences to emulate the ANI with the Average Aminoacid Identity [AAI, @konstantinidisGenomeBasedTaxonomyProkaryotes2005], but without explicit threshold for genus delineation [@rodriguez-rBypassingCultivationIdentify2014]. Tentative threshold were published later [@konstantinidisUncultivatedMicrobesNeed2017], but are seldom mentioned in AAI tools implementations [@dieckmannEDGAR3ComparativeGenomics2021; @kimIntroducingEzAAIPipeline2021; @medlarAAIprofilerFastProteomewide2018].
An alternative genus delineation method was proposed with an interpretable metric: the Percentage of Conserved Proteins (POCP) [@qinProposedGenusBoundary2014].
If two bacterial entities share more than half of their conserved proteins, i.e., POCP > 50%, they belong to the same genus.

POCP serves as a line of evidence within a taxonomic inquiry in the automated description of novel bacterial taxa by Protologger [@hitch_automated_2021].
However, the number of valid genus names has nearly doubled (@suppfig-lpsn) in the ten years since the original proposition of @qinProposedGenusBoundary2014 to delineate genera. This increase warrants for scalable methods as well as a timely reevaluation of POCP with an extended dataset.


POCP calculations require many-against-many proteins alignment tools, which are computationally demanding.
Scientists could of course invest in more hardware to scale up these computations, but this short-term solution is not sustainable. 
Few scientists or microbiology teams have access to "20 000 GPUs" even if that would significantly speed up many-against-many proteins alignments [@selvitopiExtremeScaleManyagainstManyProtein2022].

@hernandez-salmeronProgressQuicklyFinding2020 compared proteins alignment tools to find faster alternatives that are as precise. Such tools are also used in POCP calculations, but this benchmark ranked tools to identify orthologs not to calculate POCP. Recently, @holzerPOCPnfAutomaticNextflow2024 suggested to use DIAMOND with ultra-sensitive settings to compute POCP faster than with BLASTP. His approach is based on previously available script [@holzerHoelzerPocp2020], now transformed into a useful nextflow workflow [@holzerPOCPnfAutomaticNextflow2024]. However, his comparisons are based on limited set of 5 genera, each ranging from 15 to 167 genomes. 
@riescoUpdateProposedMinimal2024 evaluated much more genomes -- 1 573 type strains -- but calculated POCP -- using Bio-Py [@linSilentGeneBiopyBiopy2021] -- only to be compared with AAI.
However, the tools in these studies implicitly assume conserved proteins have unique matches [@holzerHoelzerPocp2020; @holzerPOCPnfAutomaticNextflow2024;@riescoUpdateProposedMinimal2024;@linSilentGeneBiopyBiopy2021]. This discrepancy probably stems from a subjective and personal interpretation of the original implementation [@qinProposedGenusBoundary2014].
We need a clear definition of POCP to prevent bioinformatics tools with unclear implementation to proliferate, which impedes results repeatability.


First, we aim to identify a scalable alternative to BLASTP to compute POCP. Whilst fast and scalable, this alternative should not compromise the accuracy of the legacy approach.
Second, we hypothesize that POCP provides an interpretable and already used metric that can delineate bacterial genera in most cases.
Therefore, we will test our hypothesis and evaluate how well POCP can delineate correctly bacterial genera using the identified alternative.
Eventually, we hope to provide modern microbiologists with a best-practice tool they can confidently use in their workflow to assess whether their isolates belong to a novel genus.

::: {#suppfig-lpsn}

```{r suppfiglpsn}
#| fig-width: 6
#| fig-height: 9
#| fig-dpi: 300
tar_read(fig_lpsn_stats)
```

Cumulative number of validly published genera names according to the International Code of Nomenclature of Prokaryotes (ICNP). The year 2014 is highlighted as it corresponds to the year of publication of the paper by Qin et al. (doi: 10.1128/JB.01688-14) describing the Percentage of Conserved Proteins (POCP) to delineate genus. The number of valid genera is highlighted ten years later. The data was accessed on 2024-07-19 at the List of Prokaryotic names with Standing in Nomenclature.
:::



# Methods

## GTDB bacterial proteins sequences and taxonomy as gold standard

Publicly-available microbial proteins sequences from shortlisted bacteria were used for our comparison.
The Genome Taxonomy DataBase (GTDB) is a well-maintained and metadata rich microbial resource that provides curated taxonomy along genomes and genome-derived proteins sequences [@parksGTDBOngoingCensus2022].
We devised inclusion criteria to span a wide breadth of the phylogenetic tree while maintaining achievable comparisons with the time, human and computing resources available.

Any bacterial entry available in the GTDB (r214) was included provided (1) the bacteria has a valid name according to the LPSN, (2) the entry is a representative genome, (3) the bacteria belongs to a family with at least two genuses, and (5) it belongs to a genus with at least ten genomes.

Since version r214, GTDB provides proteins sequences FASTA file (`.faa`) as compressed files (`.gz`).
While we support the decision to save storage and network load, we had to add an extraction step before use to ensure a fair comparison as only BLAST cannot natively process compressed FASTA files.

We used r214.0 and are aware that r214.1 corrected the taxonomy assignation of the genome `GB_GCA_902406375.1` to *Collinsella sp002232035*.
This change did not impact our study as the genome in question is not part of the shortlist.

The bacterial phylogenetic tree of the shortlisted genomes was constructed by trimming the bacterial tree released by GTDB using custom Python scripts and the ETE3 library [@huerta-cepasETEReconstructionAnalysis2016].


Expected pairwise comparisons between a query sequence ($Q$) and a subject sequence ($S$) were defined by banning self-comparisons ($Q \neq S$) and considering reciprocal comparisons ($Q\text{-}S$ and $S\text{-}Q$) only within the same family to prevent exponential explosion.


## Definition of Percentage of Conserved Proteins (POCP)

The percentage of conserved proteins (POCP) between two genomes $Q$ and $S$ is defined as:

$$
POCP = \dfrac{C_{QS} + C_{SQ}}{T_Q + T_S} \times 100\%
$$ {#eq-pocp}

where $C_{QS}$ represent the conserved number of proteins from $Q$ when aligned to $S$ and conversely $C_{SQ}$ represent the conserved number of proteins from $S$ when aligned to $Q$, and $T_Q + T_S$ represent the total number of proteins in the two genomes being compared, respectively [adapted from @qinProposedGenusBoundary2014].
The range of POCP is theoretically $\left[0-100\%\right]$.
Conserved proteins are defined as protein sequences matches from the query with an e-value < $10^{âˆ’5}$, a sequence identity > 40%, and an aligned region > 50% of the query protein sequence length.


However, proteins sequences from the query can match multiple subject sequences in the case of duplicated genes.
While briefly mentioned in the original paper that "The number of conserved proteins in each genome of strains being compared was slightly different because of the existence of duplicate genes (paralogs)" [@qinProposedGenusBoundary2014, p. 2211], the expected influence on the POCP values is lacking.
In our experience, this results in POCP values above the theoretical upper bound of 100%.
Therefore, we defined the POCP with unique matches (POCPu) between two genomes $Q$ and $S$ as:

$$
POCPu = \dfrac{C_{uQS} + C_{uSQ}}{T_Q + T_S} \times 100\%
$$ {#eq-pocpu}

where $C_{uQS}$ represent the conserved number of proteins from *the unique matches of* $Q$ when aligned to $S$ and conversely $C_{uSQ}$ represent the conserved number of proteins from *the unique matches of* $S$ when aligned to $Q$, and $T_Q + T_S$ represent the total number of proteins in the two genomes being compared, respectively.
Thus the range of POCP is actually $\left[0-\infty\right[$ and the range of POCPu is $\left[0-100\%\right]$.
Note that the assumption regarding unique matches is made implicitly when using some POCP implementation [e.g., @holzerHoelzerPocp2020; @holzerPOCPnfAutomaticNextflow2024; @linSilentGeneBiopyBiopy2021].

## Approaches for proteins sequence alignment benchmark

Many-versus-many proteins sequences comparisons are required to assess the number of conserved proteins.
While @qinProposedGenusBoundary2014 provided limited guidance on how to implement the computation of POCP, it is assumed that the BLASTP algorithm is the standard.
It is the approach implemented in Protologger [@hitch_automated_2021].
We first use the BLASTP approach v2.14.0+ [@camachoBLASTArchitectureApplications2009] using the parameters fitting @qinProposedGenusBoundary2014 procedure (@tbl-tools-parameters).
We also considered a slightly altered BLASTP approach, named BLASTPDB where BLAST databases are first built for the two genomes considered (@tbl-tools-parameters).
This allow parallel alignments on multiple CPU, which is not possible with BLASTP.
We then included two tools that are usually used as faster BLASTP alternatives: DIAMOND v2.1.6 [@buchfinkSensitiveProteinAlignments2021] and MMseqs2 v15.6f452 [@steineggerMMseqs2EnablesSensitive2017].
The former is being used in @holzerPOCPnfAutomaticNextflow2024 while the latter is used in EzAAI [@kimIntroducingEzAAIPipeline2021].
Similarly to BLASTPDB, these approaches require that a protein database is built for each genome before performing the alignment (@tbl-tools-parameters).
DIAMOND and MMseqs2 were both used with four different sensitivity thresholds (@tbl-tools-parameters) on a recent comparisons [@buchfinkSensitiveProteinAlignments2021].

```{r tbl-tools-parameters}
#| tbl-cap: "List of the ten approaches and associated parameters for the many-versus-many proteins alignments tools used in the benchmark. The recommended approach is indicated in bold."
tibble::tribble(
  ~Name, ~Parameters,
  "BLAST_BLASTP","--evalue 0.00001 --qcov_hsp_perc 50.0",
  "BLAST_BLASTPDB","--evalue 0.00001 --qcov_hsp_perc 50.0",
  "DIAMOND_FAST","--evalue 0.00001 --query-cover 50.0 --fast",
  "DIAMOND_SENSITIVE","--evalue 0.00001 --query-cover 50.0 --sensitive",
  "DIAMOND_VERYSENSITIVE","--evalue 0.00001 --query-cover 50.0 --very-sensitive",
  "DIAMOND_ULTRASENSITIVE","--evalue 0.00001 --query-cover 50.0 --ultra-sensitive",
  "MMSEQS2_S1DOT0","--e-profile 0.00001 --cov-mode 1 -c 0.50 -s 1.0",
  "MMSEQS2_S2DOT5","--e-profile 0.00001 --cov-mode 1 -c 0.50 -s 2.5",
  "MMSEQS2_S6DOT0","--e-profile 0.00001 --cov-mode 1 -c 0.50 -s 6.0",
  "MMSEQS2_S7DOT5","--e-profile 0.00001 --cov-mode 1 -c 0.50 -s 7.5"
) %>% 
  mutate(
    Name = if_else(Name=="DIAMOND_VERYSENSITIVE", "**DIAMOND_VERYSENSITIVE**", Name),
    `Needs database?` = if_else(Name == "BLAST_BLASTP", "No", "Yes"),
    Parameters = glue::glue("`{p}`", p=Parameters)
    ) %>%
  rename("Approach name"="Name") %>% 
  select(`Approach name`, `Needs database?`, Parameters) %>% knitr::kable()
```

All proteins matches were filtered to keep only matches with > 40 % identity to all the query sequences matches for POCP ($C_{QS}$ and $C_{SQ}$ in @eq-pocp) and only unique query sequence matches for POCPu ($C_{QS}$ and $C_{SQ}$ in @eq-pocpu).
Note that the filtering was adapted to the method as the range of percentage of identity in MMseqs2 is $[0-1]$ and $[0-100]$ for BLAST and DIAMOND.
The total number of proteins per genomes ($T_Q$ and $T_S$ in @eq-pocp and @eq-pocpu) was computed using seqkit stats v2.2.0 [@shenSeqKitCrossPlatformUltrafast2016].

Linear regressions were used in `r R.version.string` to fit the expected POCP (or POCPu) values obtained via the legacy BLAST_BLASTP approach against the others approaches considered.
The coefficient of determination R^2^ of the linear regression is used as an interpretable and bounded goodness-of-fit measure between the expected and measured values instead of others errors measurement [@chiccoCoefficientDeterminationRsquared2021].
We did not rely on the adjusted coefficient of determination as the linear regressions had only one predictor, namely the POCP (or POCPu) values of the evaluated approach.


## Metrics to evaluate genus delineation

We computed classification metrics with a positive event defined as "both genomes belong to the same genus".
Thus, for a pair of bacterial genomes with a POCP (or POCPu) > 50%, the pair is a True Positive ($TP$) if the pair belong to the same genus, or if not to False Positive ($FP$).
Conversely, for a pair of bacterial genomes with a POCP (or POCPu) $\leq$ 50%, the pair is a False Negative ($FN$) if the pair belong to the same genus, or if not to True Negative ($TN$).
We use the Sensitivity (${TP}/{TP+FN}$), Specificity (${TN}/{TN+FP}$), and the False-discovery rate (${FP}/{FP+TP}$) to assess the classification performance of both POCP and POCPu.


## Workflow implementation

Automatic protein sequences download, data preprocessing, many-versus-many protein alignments, as well as POCP computation and delineation metrics calculations were run using the workflow tool nextflow v23.10.0 [@ditommasoNextflowEnablesReproducible2017], as well as components of nf-core [@ewelsNfcoreFrameworkCommunitycurated2020].
On top of a workflow manager, tools used in the benchmark are shipped within Docker container [@merkelDockerLightweightLinux2014]  or bioconda [@thebiocondateamBiocondaSustainableComprehensive2018] environments to ensure reproducibility, scalability and ease future extensions of the benchmark.

Nextflow natively keep track of the time, CPU, memory and disk usage of each process in an execution trace log file that we used to evaluate computing resources utilization. Process duration is available as walltime and realtime, the CPU usage is reported as a percentage of usage of a unique CPU, meaning multi-threaded processes will have a value higher than 100%.

Statistical analyses, data crunching and visualisation were orchestrated with the R workflow manager targets v.1.7.0 [@landauTargetsPackageDynamic2021].


# Results

We evaluated ten proteins alignment approaches based on three tools for improved genus delineation using the Percentage Of Conserved Proteins (POCP) using publicly-available data from the GTDB [@parksGTDBOngoingCensus2022].


```{r funnel}
funnel <- c(
  "GTDB_Genomes" = 394932,
  "Representatives" = 80789,
  "Valid_names" = 11699,
  "More_10_species_per_genus" = 5904,
  "More_1_genus_per_family" = 4767
)
funnel_text <- funnel %>% prettyNum(big.mark=" ") %>% as.list() %>% 
  glue::glue_data(
    "Out of a total of {GTDB_Genomes} GTDB bacterial genomes",
    "{Representatives} are representative genomes with proper taxonomy",
    "{Valid_names} have valid names",
    "{More_10_species_per_genus} belongs to a genus with at least ten genomes",
    "and {More_1_genus_per_family} belongs to a family with at least two genera", .sep = ", "
    )
phyla_count_text <- tar_read(tree_metadata) %>%
  count(Phylum) %>% arrange(desc(n)) %>%
  glue::glue_data("{Phylum} (n = {n})",
                  n = prettyNum(n, big.mark=" ")) %>%
  glue::glue_collapse(sep = ", ", last = " and ")
```



`r funnel_text`.
This thousand-genomes shortlist provides a representative sample of bacterial phylogenetic diversity (@fig-tree-phyla A) that is divided between four phyla: `r phyla_count_text`.


```{r cpu_hours}
overall_stats <- tar_read(family_metadata) %>%
  select(Family,benchmark_type, n_genomes,CPU_hours) %>%
  mutate(
    n_comparisons_planned=n_genomes*(n_genomes-1),
    n_comparisons_realized=if_else(benchmark_type=="full",
                          n_comparisons_planned*10, n_comparisons_planned)
                          ) %>%
  summarise(
    n_planned = sum(n_comparisons_planned*10),
    n_realized = sum(n_comparisons_realized),
    total_hours = sum(CPU_hours) %>% round(),
    total_years = as.period(total_hours, unit = "hours") %>% as.numeric("years")
  ) %>% mutate(across(n_realized:total_years, ~prettyNum(.x,big.mark = " ", digits=2)))
n_planned_print <- prettyunits::pretty_num(overall_stats$n_planned, style = "nopad")
```


This should have resulted in `r n_planned_print` pairwise comparisons to be run for each of the ten approaches considered (@tbl-tools-parameters) totalizing > 10 millions processes.
However, early results from the first 17 out of 35 families to be ran were so compelling that we decided to save human and computing resources by splitting the families into two benchmark group: the full benchmark using all ten approaches or using only the recommended approach.
Genomes from all around the tree are included in the two groups (@fig-tree-phyla A) and in all the four phyla (@fig-tree-phyla B).
Still, this study needed `r overall_stats$n_realized` pairwise comparisons for a total of `r overall_stats$total_hours` CPU-Hours (`r overall_stats$total_years` in years).

::: {#fig-tree-phyla}

```{r tree-phyla}
#| fig-width: 7
#| fig-height: 10
#| fig-dpi: 300
library(ggtree)
tar_load(c(fig_phyla_count, fig_tree))
leg<-cowplot::get_legend(fig_phyla_count)
n_genomes <- nrow(tar_read(genome_metadata)) %>% prettyNum(big.mark=" ")
plot_grid(
  ggtree::rotate_tree(fig_tree, 20),
  fig_phyla_count+theme(legend.position = "none"),
  nrow = 2, labels = "AUTO",
  rel_heights = c(0.7,0.3)
)+draw_plot(leg, x=0.65,y=-0.15)
```

Overview of the phylogenetic diversity of the genomes shortlisted for the benchmark. The `r n_genomes` genomes are placed on the phylogenetic tree of the GTDB (A) and colored depending whether the genomes were included in the benchmark with all approaches (shamrock green) or only with the recommended approach (sky magenta). The distribution of genomes by Phyla is indicated for each benchmark type (B).
:::

## Comparison with the BLAST_BLASTP legacy approach

```{r genomes-in-full}
n_genomes_in_full <- targets::tar_read(tree_metadata) %>%
  count(benchmark_type) %>%
  deframe() %>%
  .[["All approaches"]] %>%
  prettyNum(big.mark = " ")
```


Using the `r n_genomes_in_full` genomes from the full benchmark (@fig-tree-phyla), we evaluate whether the accuracy of the POCP calculation is not sacrificed in the name of computational performance.

We first made sure that the database approach to BLAST_BLASTP (@tbl-tools-parameters), that allows for parallel computations produced similar POCP values to the BLAST_BLASTP approach (@suppfig-blastdb A).

::: {#suppfig-blastdb}
```{r blastdb}
#| fig-width: 9
#| fig-height: 5
#| fig-dpi: 300
n_blastdb_comparisons <- tar_read(blast_vs_all_pocpu) %>%
  count(tool) %>% pull(n) %>%
  unique() %>% prettyNum(big.mark=" ")
tar_read(fig_blast_vs_blastdb)
```

Adequacy between POCP (A) and POCPu (B) values computed with the legacy BLAST_BLASTP against the BLAST_BLASTPDB approach that build databases before alignment.
Each point ($n$ = `r n_blastdb_comparisons` per tool) represents a POCP/POCPu value between two genomes (see @eq-pocp and @eq-pocpu).
The colors represent the probability of finding a point within a certain region, with darker colors indicating higher probabilities. The regions shown are the smallest areas that contain 50%, 80%, 95%, 99% and 100% of the data points, and are known as Highest Density Regions (HDRs).
Coefficient of determination ($R^2$) and associated $p$-value are shown on top of each linear regressions.
:::



::: {#tbl-R2}

```{r R2}
#| classes: plain
library(gt)
tar_load(R2_table)
n_comparisons_in_lm <- unique(R2_table$POCP_nobs) %>% prettyNum(big.mark = " ")
R2_table %>% arrange(desc(POCPu_R2)) %>%
    gt::gt(rowname_col = "tool") %>%
    tab_stubhead("Approach name") %>% cols_align(align = "left", columns = "tool") %>%
    tab_spanner("POCP", starts_with("POCP_")) %>%
    tab_spanner("POCPu", starts_with("POCPu_")) %>% cols_hide(ends_with("_nobs")) %>%
    cols_label(
      POCP_R2 = md("$R^2$"),POCPu_R2 = md("$R^2$"),
      POCP_p_label = md("$p$-value"),POCPu_p_label = md("$p$-value")
    ) %>%
  tab_options(column_labels.font.weight = "bold")
```

Coefficient of determination ($R^2$) and associated $p$-value for linear regressions matching the POCP and POCPu values computed by each approach against the respective POCP and POCPu values of BLAST_BLASTP legacy approach. Each linear regression are based on $n$ = `r n_comparisons_in_lm` comparisons per approach. Approaches are sorted by decreasing POCPu $R^2$ values.
:::


All flavors of DIAMOND have a coefficient of determination ($R^2$) above 0.99 when matching their POCP values with the original from BLAST_BLASTP, with the exception of the DIAMOND_FAST approach that deviates more from the expected values (@fig-blast-vs-all-pocp and @tbl-R2).
This deviation is exacerbated when using the MMSEQS2_S1DOT0 approach, but is somehow rescued with the others MMSEQS2 approaches, though they perform worse than the DIAMOND approaches.
It should be noted that the reported POCP values exceed the supposed POCP upper bound of 100% (@fig-blast-vs-all-pocp).


::: {#fig-blast-vs-all-pocp}

```{r blast_vs_all_pocp}
#| fig-width: 9
#| fig-height: 5
#| fig-dpi: 300
n_blast_comparisons <- tar_read(blast_vs_all_pocp) %>%
  count(tool) %>% pull(n) %>%
  unique() %>% prettyNum(big.mark=" ")
tar_read(fig_blast_vs_all_pocp)
```

Adequacy between POCP values computed with the legacy BLAST_BLASTP against flavors of faster alternatives: DIAMOND [@buchfinkSensitiveProteinAlignments2021] and MMSEQS2 [@steineggerMMseqs2EnablesSensitive2017].
Each point ($n$ = `r n_blast_comparisons` per tool) represents a POCP value between two genomes (see @eq-pocp).
The colors represent the probability of finding a point within a certain region, with darker colors indicating higher probabilities. The regions shown are the smallest areas that contain 50%, 80%, 95%, 99% and 100% of the data points, and are known as Highest Density Regions (HDRs).
Coefficient of determination ($R^2$) and associated $p$-value are shown on top of each linear regressions.
:::


::: {#fig-blast-vs-all-pocpu}

```{r blast_vs_all_pocpu}
#| fig-width: 9
#| fig-height: 5
#| fig-dpi: 300
n_blast_comparisons_pocpu <- tar_read(blast_vs_all_pocpu) %>%
  count(tool) %>% pull(n) %>%
  unique() %>% prettyNum(big.mark=" ")
tar_read(fig_blast_vs_all_pocpu)
```

Adequacy between POCPu values computed with the legacy BLAST_BLASTP against flavors of faster alternatives: DIAMOND [@buchfinkSensitiveProteinAlignments2021] and MMSEQS2 [@steineggerMMseqs2EnablesSensitive2017].
Each point ($n$ = `r n_blast_comparisons_pocpu` per tool) represents a POCPu value between two genomes (see @eq-pocpu).
The colors represent the probability of finding a point within a certain region, with darker colors indicating higher probabilities. The regions shown are the smallest areas that contain 50%, 80%, 95%, 99% and 100% of the data points, and are known as Highest Density Regions (HDRs).
Coefficient of determination ($R^2$) and associated $p$-value are shown on top of each linear regressions.
:::


These higher-than-100% POCP values disappears when using the POCPu (@fig-blast-vs-all-pocpu and @suppfig-blastdb B).
Otherwise, the same patterns observed for POCP hold for POCPu, though with higher values of coefficient of determination (@fig-blast-vs-all-pocpu and @tbl-R2).
The 3 different sensitive approaches of DIAMOND produce POCPu values that match perfectly the ones produce by the legacy approach BLAST_BLASTP.
However, the MMSEQS2 approaches, whilst better with POCPu than POCP, still tend to underestimate POCPu values.
For all tools, two clusters of yellow points are visible (@fig-blast-vs-all-pocpu). They indicate regions where at least 50% of the data points are located, with the first and second regions being below and above 50% on the x-axis BLAST_BLASTP POCPu, respectively. 

::: {#tbl-tools-metrics}

```{r tools-metrics}
n_processes <- tar_read(tool_table) %>% pull(n) %>% unique() %>% prettyNum(big.mark=" ")
tar_read(tool_table) %>% filter(tool!="BLAST_BLASTP") %>%
  select(-n) %>%
  rename("Approach name" = "tool",
         "Time"="time_fold", "Memory"="memory_fold",
         "CPU"="cpu_fold", "Disk usage (I/O)"="io_fold") %>% 
  knitr::kable(digits = 3)
```

Fold change of computing metrics for the 9 approaches used in the benchmark compared to the BLAST_BLASTP approach.
The metrics include processing time as real-time, memory usage, CPU usage and disk usage as input/output (I/O).
A fold change below 1 means the metric is lower, whilst above 1 means it is higher, compared to the BLAST_BLASTP approach.
The fold change values are median computed over ($n$ = `r n_processes` number of processes tracked per approach.
:::

The BLAST_BLASTPDB approach is a strong contender for a BLAST_BLASTP alternative because whilst using more resources, it performs exactly the same as BLAST_BLASTP (@suppfig-blastdb and @tbl-R2) in a fraction of the time (@tbl-tools-metrics).
Still, DIAMOND-based sensitive approaches are way faster with excellent adequacy with BLAST_BLASTP approach, especially for POCPu (@tbl-R2).
Whilst DIAMOND_ULTRASENSITIVE would have the highest $R^2$ value using POCPu (@tbl-R2), it has the highest memory consumption and disk usage of the tested approaches (@tbl-tools-metrics).
A more sustainable alternative would be DIAMOND_VERYSENSITIVE that performs 10 times faster than BLAST_BLASTPDB, in less than $1/20^{th}$ of the time of BLAST_BLASTP, while still maintaining reasonable usage of the resources (@tbl-tools-metrics).
More importantly, DIAMOND_VERYSENSITIVE POCPu provides extremely similar results to the legacy approach BLAST_BLASTP (@fig-blast-vs-all-pocpu and @tbl-R2) and is essentially identical to DIAMOND_ULTRASENSITIVE POCPu $R^2$ up to 5 digits (@tbl-R2).
Therefore, we consider DIAMOND_VERYSENSITIVE to be a valid and scalable alternative to BLAST_BLASTP for POCP/POCPu computations.

## Genus delineation with POCP and POCPu

```{r confusion_matrix}
targets::tar_load(c(pocp_confusion,pocpu_confusion))
```

Then, we put to the test the 50%-threshold of POCP and POCPu, and evaluate how useful these metrics are to delineate bacterial genera.

::: {#fig-genus-delineation}

```{r genus-delineation}
#| fig-width: 11
#| fig-height: 6
#| fig-dpi: 300
targets::tar_load(pocpu_group_sizes)
targets::tar_read(p_genus_delineation)
```


A data-driven evaluation of how well POCP and POCPu distinguish genera.
Distribution of POCP (A) and POCPu (B) values for all pairwise genome comparisons: `r pocpu_group_sizes[1]` and `r pocpu_group_sizes[2]` based on GTDB taxonomy.
Contrast these true categories with POCP/POCPu decisions: POCP > 50%, meaning right of the dashed line (A, B) indicates more than half of shared conserved proteins, and hence same genus.
POCP and POCPu values are calculated with the recommended approach DIAMOND_VERYSENSITIVE (@tbl-tools-parameters).
How well POCPu delineates genera is tested with the Matthews Correlation Coefficient [MCC, @chiccoAdvantagesMatthewsCorrelation2020]. We show MCC values for each family where MCC of -1 and +1 indicates perfect misclassification and classification, respectively (C). Random genus delineation would give MCC = 0. The dashed line indicated the overall MCC when not splitting by family. We also highlight how many n genomes are included per family, and their phyla in the vertical facets (C).
:::

# References

::: {#refs}
:::
