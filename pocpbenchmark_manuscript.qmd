---
title: Robust genome-based delineation of bacterial genera
affiliations:
  - id: 1
    name: University Hospital of RWTH Aachen
    department: Institute of Medical Microbiology
    group: Functional Microbiome Research Group
    country: Germany
    url: https://ror.org/02gm5zw39
authors:
  - name: Charlie Pauvert
    corresponding: true
    orcid: 0000-0001-9832-2507
    email: cpauvert@ukaachen.de
    affiliations:
      - ref: 1
    roles:
      - Conceptualization
      - Formal analysis
      - Investigation
      - Software
      - Visualization
      - Writing - original draft
      - Writing - review & editing
  - name: Thomas C.A. Hitch
    orcid: 0000-0003-2244-7412
    affiliations:
      - ref: 1
    roles:
      - Conceptualization
      - Supervision
      - Visualization
      - Writing - review & editing
  - name: Thomas Clavel
    corresponding: true
    email: tclavel@ukaachen.de
    orcid: 0000-0002-7229-5595
    affiliations:
      - ref: 1
    roles:
      - Funding acquisition
      - Resources
      - Writing - review & editing
license: "CC BY"
bibliography: references.bib
csl: oxford-university-press-scimed-numeric.csl
crossref:
  custom:
    - kind: float
      key: suppfig
      latex-env: suppfig
      reference-prefix: Figure S
      space-before-numbering: false
      latex-list-of-description: Supplementary Figure
abstract: |
    Genomic analysis has become essential in bacterial taxonomy, enabling fast classification of bacteria across biomes. However, quantifiable measures to make informed decision on the taxonomic placement of bacterial taxa above the level of species are rare, which hampers the stability of knowledge in databases and articles. In this work, we focused on bacterial classification at the genus level and revisited the concept of Percentage Of Conserved Proteins (POCP). Whilst POCP is broadly used as an overall genome relatedness index, the underlying tool and method of calculation differ, resulting in disparate implementations and misnomers unfit for the increasing wealth of public genomes available.
    
    We evaluated 10 protein alignments methods and found evidence for a scalable yet robust alternative to BLASTP for POCP based on 2,358,466 pairwise comparisons of 4,767 genomes across 35 families. However, we showed that certain combinations of tools and parameters are not suited for POCP calculations owing to drastic over- or underestimation. Therefore, we bring forward a clearer definition of POCP using only unique matches, termed POCPu, that showed better genus delineation than with POCP. We suggested tentative family-specific thresholds when the standard of 50% was not resolutive enough.
    
    We propose that faster bacterial genus delineation should be calculated with DIAMOND using very-sensitive settings and only unique matches (POCPu). We advise microbiologists to carefully assess that the tools used for genus assignment match their biological assumptions to avoid misguided inferences.
notebook-links: false
keywords: [bacterial taxonomy, bacterial genomics, genus delineation, protein sequence comparison, percentage of conserved proteins (POCP), benchmark]
---

```{r setup}
library(tidyverse)
library(targets)
library(cowplot)
library(gt)
```


# Introduction

Bacterial taxonomy is the classification of bacterial strains into lineages ranging from phyla to species within the domain Bacteria. This is critical to our understanding of bacterial diversity by creating a coherent framework that reflect their evolutionary relationships.
Two elements show that accurate taxonomic placement of microorganisms is more important now than ever: (i) a very high fraction of bacteria, both in the environment and host-associated microbiomes, remain to be described and named [@sutcliffeAddressingSublimeScale2021; @thomasMultipleLevelsUnknown2019]; (ii) large-scale metagenomic studies in the last decade and now high-throughput cultivation methods are accelerating the pace of bacterial discovery [@hugenholtzProkaryoticTaxonomyNomenclature2021].
It is therefore essential to consolidate the system for classifying bacteria. Whilst bacteria had been classified based on morphology and phenotypic parameters for decades, the advent of genomics has revolutionised the way we classify bacteria, giving rise to a plethora of Overall Genome Relatedness Indices [@chunIntegratingGenomicsTaxonomy2014].
However, in the process of classifying bacteria, it is essential to provide a robust framework that includes easy-to-implement parameters to classify organisms at each level of bacterial lineage, including the genus level, which is the focus in this article. 

The Genome Taxonomy Database (GTDB) has proposed a standardized approach to group publicly available genomes into species clusters [@parksCompleteDomaintospeciesTaxonomy2020], resulting in an invaluable resource that is regularly updated and adopted by the community [@parksGTDBOngoingCensus2022]. 
The approach is resilient to genome contamination, which can plague public repositories [@mussigPutativeGenomeContamination2024], but also includes cases of taxonomic incongruence with previously described and accepted species names [@parksCompleteDomaintospeciesTaxonomy2020].

In the last three years alone, the number of bacterial genomes in the RefSeq collection has increased by 35,000 per year, both from isolates and metagenomes [@haftRefSeqProkaryoticGenome2024]. To analyse these genomes, we need clear and rapid methods for taxonomic assignment.
For species, Average Nucleotide Identity [ANI, @jainHighThroughputANI2018] has been developed and shown to delineate species almost unanimously [@parksCompleteDomaintospeciesTaxonomy2020].
However, ANI is unable to delineate genera [@qinProposedGenusBoundary2014].
While no single ANI threshold has been proposed for genus delineation, family-specific thresholds have been suggested using both the ANI value and alignment fraction, however the lack of a universal threshold limits their usability [@barcoGenusDefinitionBacteria2020].
An alternative to ANI is the Average Amino acid Identity (AAI) which uses protein sequences instead of genomic nucleic sequences [@konstantinidisGenomeBasedTaxonomyProkaryotes2005].
A genus delineation threshold based on AAI has been proposed [@konstantinidisUncultivatedMicrobesNeed2017], but this approach is rarely applied [@dieckmannEDGAR3ComparativeGenomics2021; @kimIntroducingEzAAIPipeline2021; @medlarAAIprofilerFastProteomewide2018].
A protein sequence-based genus delineation method proposed with an interpretable metric is the Percentage of Conserved Proteins (POCP) [@qinProposedGenusBoundary2014].
In this system, if two bacterial entities share more than half of their conserved proteins, i.e., POCP > 50%, they are considered to belong to the same genus.

POCP is widely used in the community to assign novel bacterial taxa to known genera, or support the proposal of novel genera [@afrizalEnhancedCulturedDiversity2022; @chaplinHydrogeniiclostidiumMannosilyticumGen2020; @gonzalezAcidiferrimicrobiumAustraleGen2020; @hitchBroadDiversityHuman2024; @wylensekCollectionBacterialIsolates2020;@kuzmanovicTaxonomyRhizobiaceaeRevisited2022; @liuEnlighteningTaxonomyDarkness2021; @orataPhylogenomicAnalysisGammaproteobacterial2018; @sereikaClosedGenomesUncover2023]
However, the validity of the threshold value aforementioned has not been widely tested. In addition, a major limitation of POCP is that comparing all proteins within each genome to each other is computationally demanding.
Given that the number of valid genus names almost doubled since the original proposition of POCP by Qin et al. @qinProposedGenusBoundary2014 (@suppfig-lpsn), scalable methods as well as a timely re-evaluation of the POCP approach is needed.


Hernández-Salmerón et al. @hernandez-salmeronProgressQuicklyFinding2020 compared proteins alignment tools to find faster alternatives to find reciprocal best hits, without a loss in precision.
They found that DIAMOND [@buchfinkSensitiveProteinAlignments2021], when switched to sensitive parameters instead of defaults, correctly found 87% of the reciprocal best hits of BLASTP [@camachoBLASTArchitectureApplications2009] in less than 8% of the computing time.
Recently, Hölzer @holzerPOCPnfAutomaticNextflow2024 suggested the use of DIAMOND with ultra-sensitive settings to compute POCP faster than with BLASTP. This method was based on previously available code [@holzerHoelzerPocp2020], implemented as a nextflow workflow [@holzerPOCPnfAutomaticNextflow2024]. However, this new method was only validated on 5 genera, with 15 to 167 genomes each. 
Fundamental changes, such as the tool selected, can have significant effects on calculations, especially if 13% of matching proteins may not be found.
Current implementations of POCP have also modified the calculation of POCP by limiting the calculation of conserved proteins to unique matches [@holzerHoelzerPocp2020; @holzerPOCPnfAutomaticNextflow2024;@riescoUpdateProposedMinimal2024;@linSilentGeneBiopyBiopy2021], in contrast to the original implementation of POCP which had no such limitation [@qinProposedGenusBoundary2014].
These studies clearly show the urgent need for a clear definition of POCP to avoid divergent assumptions in tools between microbiologists and developers.
Furthermore, there is an urgent need for extensive benchmarking of POCP to enhance reproducibility and accuracy given the increased number of genomic resources available.

```{r overall_stats_cpu_hours}
stats_by_type <- tar_read(family_metadata) %>%
  select(Family,benchmark_type, n_genomes,CPU_hours) %>%
  group_by(benchmark_type) %>% 
  mutate(
    n_comparisons_planned=n_genomes*(n_genomes-1),
    n_comparisons_realized=if_else(benchmark_type=="full",
                          n_comparisons_planned*10, n_comparisons_planned)
                          ) %>%
  summarise(
    n_families = n(),
    n_genomes = sum(n_genomes),
    n_planned = sum(n_comparisons_planned*10),
    n_realized = sum(n_comparisons_realized),
    total_hours = sum(CPU_hours)
    )
overall_stats <- stats_by_type %>% 
  summarise(across(!benchmark_type,sum)) %>% 
  mutate(
    total_hours = round(total_hours),
    total_years = as.period(total_hours, unit = "hours") %>% as.numeric("years")
  ) %>% mutate(across(everything(), ~prettyNum(.x,big.mark = ",", digits=2)))
```


To achieve this, we created a scalable alternative to BLASTP for computing POCP. This alternative is fast and did not compromise the accuracy of the original approach.
Secondly, because POCP provides an interpretable and used metric but the proposed threshold needs to be assessed in a comprehensive manner, we evaluated the ability of the optimised POCP implementation to correctly delineate bacterial genera based on `r overall_stats[["n_realized"]]` pairwise comparisons of `r overall_stats[["n_genomes"]]` genomes across `r overall_stats[["n_families"]]` families.

::: {#suppfig-lpsn}

```{r suppfiglpsn}
knitr::include_graphics(tar_read(fig_lpsn_stats_png))
```

Cumulative number of validly published genera names according to the International Code of Nomenclature of Prokaryotes (ICNP). The year 2014 is highlighted as it corresponds to the year of publication of the paper by Qin et al. (doi: 10.1128/JB.01688-14) describing the Percentage of Conserved Proteins (POCP) to delineate genus. The number of valid genera is highlighted ten years later. The data was accessed on 2024-12-11 at the List of Prokaryotic names with Standing in Nomenclature [@parteListProkaryoticNames2020].
:::



# Materials and methods

## Standardisation of protein sequences and taxonomy via GTDB

As GTDB provides curated taxonomy along with genomes and genome-derived proteins sequences [@parksGTDBOngoingCensus2022], we used it as a reliable source of high-quality data in our benchmark.
We used inclusion criteria to facilitate the selection of a diverse range of taxonomic groups from GTDB (r214) (N = 394,932 bacterial genomes), while maintaining achievable comparisons with the time, human, and computing resources available: (1) the bacteria had a valid name according to the List of Prokaryotic names with Standing in Nomenclature [@parteListProkaryoticNames2020] and a representative genome was available (N = 11,699), (2) they belonged to a family with at least two genera (N = 5,904), and (3) to a genus with at least ten genomes (N = 4,767).
Based on these criteria, the protein sequence files for the shortlisted bacteria were obtained from GTDB (Table S1).


```{r funnel}
funnel <- c(
  "GTDB_Genomes" = 394932,
  "Representatives" = 80789,
  "Valid_names" = 11699,
  "More_10_species_per_genus" = 5904,
  "More_1_genus_per_family" = 4767
)
```

## Definition of Percentage of Conserved Proteins (POCP)

The percentage of conserved proteins (POCP) between two genomes $Q$ and $S$ is defined as:

$$
POCP = \dfrac{C_{QS} + C_{SQ}}{T_Q + T_S} \times 100\%
$$ {#eq-pocp}

where $C_{QS}$ represents the conserved number of proteins from $Q$ when aligned to $S$ and conversely $C_{SQ}$ represents the conserved number of proteins from $S$ when aligned to $Q$; $T_Q + T_S$ represents the total number of proteins in each of the two genomes being compared [adapted from @qinProposedGenusBoundary2014].
The range of POCP is theoretically $\left[0;100\%\right]$.
Conserved proteins are defined as protein sequences matches from the query with an e-value < $10^{−5}$, a sequence identity > 40%, and an aligned region > 50% of the query protein sequence length.

Pairwise comparisons between a query sequence ($Q$) and a subject sequence ($S$) were defined by banning self-comparisons ($Q \neq S$) and considering reciprocal comparisons ($Q\text{-}S$ and $S\text{-}Q$) only within the same family to avoid unnecessary expansion of the comparison landscape.


## Benchmarking methods for proteins sequence alignment

In @qinProposedGenusBoundary2014, guidance was provided on how to implement the computation of POCP, including the use of BLASTP.
As 'standard' POCP method, we used BLASTP v2.14.0+ [@camachoBLASTArchitectureApplications2009] with parameters from @qinProposedGenusBoundary2014 (@tbl-tools-parameters).
We also considered a modified implementation of the BLASTP method, named BLASTPDB where BLAST databases are first built for the two genomes considered (@tbl-tools-parameters).
This allows parallel alignments on multiple CPU, which is not possible with BLASTP.
We then included two tools that were designed as faster local-protein-alignment methods and used as alternatives to BLASTP: DIAMOND v2.1.6 [@buchfinkSensitiveProteinAlignments2021] and MMseqs2 v15.6f452 [@steineggerMMseqs2EnablesSensitive2017].
The former is used in @holzerPOCPnfAutomaticNextflow2024 while the latter is used in EzAAI [@kimIntroducingEzAAIPipeline2021].
Similar to BLASTPDB, these methods require that a protein database is built for each genome before performing the alignment (@tbl-tools-parameters).
DIAMOND and MMseqs2 were both used with four different sensitivity thresholds proposed recently (@tbl-tools-parameters) [@buchfinkSensitiveProteinAlignments2021].

::: {#tbl-tools-parameters}

```{r tools-parameters}
tibble::tribble(
  ~Name, ~Parameters,
  "BLAST_BLASTP","--evalue 0.00001 --qcov_hsp_perc 50.0",
  "BLAST_BLASTPDB","--evalue 0.00001 --qcov_hsp_perc 50.0",
  "DIAMOND_FAST","--evalue 0.00001 --query-cover 50.0 --fast",
  "DIAMOND_SENSITIVE","--evalue 0.00001 --query-cover 50.0 --sensitive",
  "DIAMOND_VERYSENSITIVE","--evalue 0.00001 --query-cover 50.0 --very-sensitive",
  "DIAMOND_ULTRASENSITIVE","--evalue 0.00001 --query-cover 50.0 --ultra-sensitive",
  "MMSEQS2_S1DOT0","--e-profile 0.00001 --cov-mode 1 -c 0.50 -s 1.0",
  "MMSEQS2_S2DOT5","--e-profile 0.00001 --cov-mode 1 -c 0.50 -s 2.5",
  "MMSEQS2_S6DOT0","--e-profile 0.00001 --cov-mode 1 -c 0.50 -s 6.0",
  "MMSEQS2_S7DOT5","--e-profile 0.00001 --cov-mode 1 -c 0.50 -s 7.5"
) %>% 
  mutate(
    `Database creation` = if_else(Name == "BLAST_BLASTP", "No", "Yes"),
    category = str_remove(Name, "_.*")
  ) %>%
  dplyr::rename("Method" = "Name") %>% group_by(category) %>%
  gt::gt() %>%
  tab_style(
    style = cell_text(font = system_fonts(name = "monospace-code")),
    locations = cells_body(columns = "Parameters")
  ) %>%
  tab_style_body(
    cell_text(weight = "bold"),
    values = "DIAMOND_VERYSENSITIVE",
    targets = "row"
  ) %>% 
  cols_move_to_end("Parameters") %>% 
 tab_options(
   column_labels.font.weight = "bold",
   column_labels.font.size = "small",
   table.font.size = "small"
 )
```

List of the ten methods and associated parameters for the many-versus-many proteins alignments tools used in the benchmark. The recommended approach is indicated in bold.
:::

All proteins matches were filtered to only keep matches with > 40 % identity to all the query sequences matches for POCP ($C_{QS}$ and $C_{SQ}$ in @eq-pocp) and only unique query sequence matches for POCPu ($C_{QS}$ and $C_{SQ}$ in @eq-pocpu).
The filtering was adapted to the method as the range of percentage of identity in MMseqs2 is $[0-1]$ and $[0-100]$ for BLAST and DIAMOND.
The total number of proteins per genomes ($T_Q$ and $T_S$ in @eq-pocp and @eq-pocpu) was computed using seqkit stats v2.2.0 [@shenSeqKitCrossPlatformUltrafast2016].

Linear regressions were implemented using `r R.version.string` to fit the expected POCP (or POCPu) values obtained via the BLAST_BLASTP reference method against the other methods considered.
The coefficient of determination R^2^ of the linear regression is used as an interpretable and bounded goodness-of-fit measure between the expected and measured values instead of other errors measurement [@chiccoCoefficientDeterminationRsquared2021].
We did not rely on the adjusted coefficient of determination as the linear regressions had only one predictor, namely the POCP (or POCPu) values of the evaluated method.


## Metrics to evaluate genus delineation

We computed classification metrics with a positive event defined as "both genomes belong to the same genus".
Thus, for a pair of bacterial genomes with a POCP (or POCPu) >50%, the pair was a True Positive ($TP$) if it belonged to the same genus, else it was considered as a False Positive ($FP$).
Conversely, for a pair of bacterial genomes with a POCP (or POCPu) $\leq$ 50%, the pair was a False Negative ($FN$) if it belonged to the same genus, else it was considered as a True Negative ($TN$).
We then assessed the classification performance of both POCP and POCPu using Matthews Correlation Coefficient (MCC; @eq-mcc).

$$
MCC = \dfrac{TP \times TN - FP \times FN}{\sqrt{(TP + FP)(TP + FN)(TN + FP)(TN+FN)}}
$$ {#eq-mcc}

The coefficient has a range of $\left[-1;+1\right]$ and is high in case of perfect classification, whilst a MCC of 0 indicates random classification. In addition, the MCC compensates for unequal class sizes compared to others metrics such as accuracy or F1-score [@chiccoAdvantagesMatthewsCorrelation2020].

We used one dimensional optimization [@brentAlgorithmsMinimizationDerivatives1972] to find family-specific POCPu thresholds maximizing MCC values and separating between-genera from within-genera distributions.
The optimization was run using the `optimize()` function from the R `stats` package [@rcoreteamLanguageEnvironmentStatistical2023].

## Workflow implementation

Automatic protein sequences download, data pre-processing, many-versus-many protein alignments, POCP computation and delineation metrics calculations have been included in a workflow using nextflow v23.10.0 [@ditommasoNextflowEnablesReproducible2017] workflow, based on components of nf-core [@ewelsNfcoreFrameworkCommunitycurated2020].
The tools used are provided within Docker container [@merkelDockerLightweightLinux2014] or bioconda [@thebiocondateamBiocondaSustainableComprehensive2018] environments to ensure reproducibility, scalability and ease future extensions of the present benchmarking work.

Nextflow natively keeps track of the time, CPU, memory and disk usage of each process in an execution trace log file, which we used to evaluate the computing resources utilization. Process duration is available as wall-time and real-time, the CPU usage is reported as a percentage of usage of a unique CPU, meaning multi-threaded processes will have a value higher than 100%.

Statistical analyses and visualization were conducted in R using targets v.1.7.0 [@landauTargetsPackageDynamic2021].



# Results

## Finding a BLASTP alternative for POCP


First, we set out to identify a scalable alternative to BLASTP to compute the Percentage Of Conserved Proteins (POCP) to delineate genera.
We evaluated ten proteins alignment methods (@tbl-tools-parameters) based on three tools -- BLASTP [@camachoBLASTArchitectureApplications2009], DIAMOND [@buchfinkSensitiveProteinAlignments2021] and MMseqs2 [@steineggerMMseqs2EnablesSensitive2017].

```{r benchmark_all_text}
phyla_count_text <- tar_read(tree_metadata) %>% filter(benchmark_type=="All approaches") %>% 
  select(Phylum:Species) %>%
  group_by(Phylum) %>%
  summarise(across(everything(),n_distinct)) %>%
  arrange(desc(Species)) %>%
  glue::glue_data(
    "_{Phylum}_ ({Family} families, {Genus} genera, {Species} species)",
    Species = prettyNum(Species, big.mark=",")) %>%
  glue::glue_collapse(sep = ", ", last = " and ")
```


```{r cpu_hours}
full_benchmark_stats <- stats_by_type %>% filter(benchmark_type=="full") %>% 
  summarise(across(!benchmark_type,sum)) %>% 
  mutate(
    total_hours = round(total_hours),
    total_years = as.period(total_hours, unit = "hours") %>% as.numeric("years")
  ) %>% mutate(across(everything(), ~prettyNum(.x,big.mark = ",", digits=2)))
stats_by_type_text <- stats_by_type %>%
  mutate(across(everything(), ~prettyNum(.x,big.mark = ",", digits=2))) %>% 
  glue::glue_data(
    "({n_families} families, {n_genomes} genomes, {n_realized} comparisons)"
    )
```


```{r genomes-in-full}
n_genomes_in_full <- stats_by_type %>% 
  filter(benchmark_type=="full") %>% pull(n_genomes) %>% 
  prettyNum(big.mark = ",")
```



```{r fraction_time}
time_fraction_category <- tar_read(tool_table) %>% 
  filter(tool != "BLAST_BLASTP") %>% 
  separate_wider_delim(tool, "_", names = c("category", "parameter")) %>% 
  group_by(category) %>% 
  summarise(
    fraction = median(1/time_fold) %>% round(),
    fraction = if_else(fraction == 2, "twice",
                       glue::glue("{fraction}x"))
  ) %>% deframe()
```


We used GTDB genomes from a wide range of bacterial phylogenetic diversity across four phyla: `r phyla_count_text`. 
We processed these `r n_genomes_in_full` genomes and conducted `r full_benchmark_stats$n_realized` pairwise comparisons with a total of `r full_benchmark_stats$total_hours` CPU-Hours (`r full_benchmark_stats$total_years` in years).
All the methods tested were faster than the reference BLASTP (@tbl-tools-metrics).
BLASTPDB, the database method of BLASTP (@tbl-tools-parameters) that enables paralleled computations, was only half the time of BLASTP on average.
In contrast, all DIAMOND and MMSEQS2-based methods ran in `r time_fraction_category[["DIAMOND"]]` and `r time_fraction_category[["MMSEQS2"]]` the speed of BLASTP, at the cost of using more memory, CPU, and disk usage (@tbl-tools-metrics).
Thus, as expected, more sensitive methods consumed more resources in general.

An important criterion for a BLASTP alternative is to evaluate whether the accuracy of POCP calculation is comparable and not compromised for increased speed.


::: {#tbl-tools-metrics}

```{r tools-metrics}
n_processes <- tar_read(tool_table) %>% pull(n) %>% unique() %>% prettyNum(big.mark=",")
tar_read(metrics_table)
```

Fold change of computing metrics for the ten methods used in the benchmark compared to the BLAST_BLASTP method.
The metrics include processing time as real-time, memory usage, CPU usage and disk usage as input/output (I/O).
A fold change below 1 means the metric was lower, above 1 means it was higher, compared to the reference.
The fold change values are median computed over $n$ = `r n_processes` number of processes tracked per approach.
:::
### DIAMOND gives POCP as accurate as BLASTP

::: {#suppfig-pocp-blastdb}
```{r pocp_blastdb}
n_blastdb_comparisons <- tar_read(blast_vs_all_pocpu) %>%
  count(tool) %>% pull(n) %>%
  unique() %>% prettyNum(big.mark=",")
knitr::include_graphics(tar_read(fig_blast_vs_blastdb_pocp_png))
```

Adequacy between POCP values computed with the reference BLAST_BLASTP against the BLAST_BLASTPDB method that build databases before alignment.
Each point ($n$ = `r n_blastdb_comparisons`) represents a POCP value between two genomes (see @eq-pocp).
The colors represent the number of data points binned together in hexagons to avoid over-plotting.
Coefficient of determination ($R^2$) and associated $p$-value are shown on top of each linear regressions.
:::


BLASTPDB produced the exact same POCP values as BLASTP (@suppfig-pocp-blastdb).
The other methods did not perform as good. All methods of DIAMOND had a coefficient of determination ($R^2$) above 0.99, except for DIAMOND_FAST that deviated from the expected values (@fig-blast-vs-all-pocp).
All DIAMOND methods, especially DIAMOND_FAST, tended to underestimate POCP values (all dots were below the reference dashed line), meaning that they might assign genomes to different genera when they are from the same genus (top panels).
Deviation from the BLASTP reference was aggravated when using the MMSEQS2_S1DOT0 method, mainly through underestimation (bottom panels).
The other MMSEQS2 methods performed better, but still less good than the DIAMOND methods.
They also tended to overestimate more than underestimate. All in all, the DIAMOND methods, especially with increased sensitivity, generated POCP values nearly as accurate as BLASTP for a fraction of the time, but we restrained from using the MMSEQS2 methods due to being less accurate.


::: {#fig-blast-vs-all-pocp}

```{r blast_vs_all_pocp}
n_blast_comparisons <- tar_read(blast_vs_all_pocp) %>%
  count(tool) %>% pull(n) %>%
  unique() %>% prettyNum(big.mark=",")
knitr::include_graphics(tar_read(fig_blast_vs_all_pocp_png))
```

Adequacy between POCP values computed with the reference method BLAST_BLASTP and methods of faster alternatives: DIAMOND [@buchfinkSensitiveProteinAlignments2021] and MMSEQS2 [@steineggerMMseqs2EnablesSensitive2017].
Each point ($n$ = `r n_blast_comparisons` per tool) represents a POCP value between two genomes (see @eq-pocp).
The colors represent the number of data points binned together in hexagons to avoid over-plotting.
Coefficient of determination ($R^2$) and associated $p$-value are shown on top of each linear regressions.
:::

### Proposal for clear and fast computation of POCP values

We observed that all methods generated POCP values exceeding the supposed upper limit of 100%. Hence, we investigated the underlying reasons and suggest a clearer definition of POCP, termed POCPu.

During the alignment process, proteins sequences from the query can match multiple subject sequences in the case of duplicated genes. Whilst briefly mentioned in the original article that "The number of conserved proteins in each genome of strains being compared was slightly different because of the existence of duplicate genes (paralogs)" [@qinProposedGenusBoundary2014, p. 2211], the expected influence on the POCP values was lacking. Therefore, we defined the POCP with unique matches (POCPu) between two genomes $Q$ and $S$ as:

$$
POCPu = \dfrac{C_{uQS} + C_{uSQ}}{T_Q + T_S} \times 100\%
$$ {#eq-pocpu}

where $C_{uQS}$ represents the conserved number of proteins from *the unique matches of* $Q$ when aligned to $S$ and, conversely, $C_{uSQ}$ the conserved number of proteins from *the unique matches of* $S$ when aligned to $Q$; $T_Q + T_S$ represents the total number of proteins in each of the two genomes being compared.


::: {#suppfig-pocpu-blastdb}
```{r pocpu_blastdb}
knitr::include_graphics(tar_read(fig_blast_vs_blastdb_pocpu_png))
```

Adequacy between POCPu values computed with the reference BLAST_BLASTP against the BLAST_BLASTPDB approach that build databases before alignment.
Each point ($n$ = `r n_blastdb_comparisons`) represents a POCPu value between two genomes (see @eq-pocpu).
The colors represent the number of data points binned together in hexagons to avoid over-plotting.
Coefficient of determination ($R^2$) and associated $p$-value are shown on top of each linear regressions.
:::

::: {#fig-blast-vs-all-pocpu}

```{r blast_vs_all_pocpu}
n_blast_comparisons_pocpu <- tar_read(blast_vs_all_pocpu) %>%
  count(tool) %>% pull(n) %>%
  unique() %>% prettyNum(big.mark=",")
knitr::include_graphics(tar_read(fig_blast_vs_all_pocpu_png))
```

Adequacy between POCPu values computed with the reference method BLAST_BLASTP and methods of faster alternatives: DIAMOND [@buchfinkSensitiveProteinAlignments2021] and MMSEQS2 [@steineggerMMseqs2EnablesSensitive2017].
Each point ($n$ = `r n_blast_comparisons_pocpu` per tool) represents a POCPu value between two genomes (see @eq-pocpu).
The colors represent the number of data points binned together in hexagons to avoid over-plotting.
Coefficient of determination ($R^2$) and associated $p$-value are shown on top of each linear regressions.
:::

POCP values above 100% disappeared when using POCPu (@fig-blast-vs-all-pocpu and @suppfig-pocpu-blastdb).
In general, the same patterns observed for POCP hold for POCPu, though with higher values of coefficient of determination (@fig-blast-vs-all-pocpu and @tbl-R2).
The 3 different sensitive methods of DIAMOND produced POCPu values that matched perfectly the ones produced by the reference method BLAST_BLASTP, with no underestimation as in the case of POCP previously.
In contrast, the MMSEQS2 methods, whilst better with POCPu than POCP, still tended to underestimate POCPu values. All in all, POCPu is closer to BLASTP than POCP (@fig-blast-vs-all-pocpu) thus guiding our choice to create an accurate BLASTP alternative.



::: {#tbl-R2}

```{r R2}
#| html-table-processing: none
#| classes: plain
tar_load(R2_table)
n_comparisons_in_lm <- unique(R2_table$POCP_nobs) %>% prettyNum(big.mark = ",")
R2_table %>% arrange(desc(POCPu_R2)) %>%
    gt::gt(rowname_col = "tool") %>%
    tab_stubhead("Method") %>% cols_align(align = "left", columns = "tool") %>%
    tab_spanner("POCP", starts_with("POCP_")) %>%
    tab_spanner("POCPu", starts_with("POCPu_")) %>% cols_hide(ends_with("_nobs")) %>%
    cols_label(
      POCP_R2 = md("$R^2$"),POCPu_R2 = md("$R^2$"),
      POCP_p_label = md("$p$-value"),POCPu_p_label = md("$p$-value")
    ) %>%
  tab_options(column_labels.font.weight = "bold")
```

Coefficient of determination ($R^2$) and associated $p$-value for linear regressions matching the POCP and POCPu values computed by each method against the respective POCP and POCPu values of the reference method BLAST_BLASTP. Each linear regression are based on $n$ = `r n_comparisons_in_lm` comparisons per method. Methods are sorted by decreasing POCPu $R^2$ values.
:::


In summary, the BLAST_BLASTPDB method was a strong contender for a BLAST_BLASTP alternative because it performed exactly the same as BLAST_BLASTP (@suppfig-pocp-blastdb, @suppfig-pocpu-blastdb and @tbl-R2) in `r time_fraction_category[["BLAST"]]` the speed (@tbl-tools-metrics), at the cost of using more resources. However, the DIAMOND sensitive methods were way faster with excellent adequacy with BLAST_BLASTP, especially for POCPu (@tbl-R2).
Whilst DIAMOND_ULTRASENSITIVE had the highest $R^2$ value using POCPu (@tbl-R2), it also had the highest memory consumption and disk usage (@tbl-tools-metrics).
A more sustainable alternative is DIAMOND_VERYSENSITIVE that performed 10 times faster than BLAST_BLASTPDB, in less than a twentieth of the time of the time of BLAST_BLASTP, while still maintaining reasonable usage of the computing resources (@tbl-tools-metrics).
More importantly, POCPu values calculated using DIAMOND_VERYSENSITIVE gave results that were extremely close to the reference BLAST_BLASTP (@fig-blast-vs-all-pocpu and @tbl-R2) and were essentially identical to DIAMOND_ULTRASENSITIVE POCPu $R^2$ up to 5 digits (@tbl-R2).
Therefore, we consider DIAMOND_VERYSENSITIVE to be a valid and scalable alternative to BLAST_BLASTP for POCP/POCPu computations.

## Unique matches enhance the accuracy of genus delineation

```{r confusion_matrix}
targets::tar_load(c(pocp_confusion,pocpu_confusion))
n_genomes <- sum(stats_by_type$n_genomes) %>% prettyNum(big.mark = ",")
phyla_count_total_text <- tar_read(tree_metadata) %>% 
  select(Phylum:Species) %>%
  group_by(Phylum) %>%
  summarise(across(everything(),n_distinct)) %>%
  arrange(desc(Species)) %>%
  glue::glue_data(
    "_{Phylum}_ ({Family} families, {Genus} genera, {Species} species)",
    Species = prettyNum(Species, big.mark=",")) %>%
  glue::glue_collapse(sep = ", ", last = " and ")
```


```{r pairwise_counts_for_recommended_approach}
pairs_for_recommended <- stats_by_type %>% 
  dplyr::select(benchmark_type, n_realized) %>% 
  mutate(n_realized=if_else(
    benchmark_type == "full", n_realized/10, n_realized)
  ) %>% pull(n_realized) %>% sum() %>% 
  prettyNum(big.mark=",")
```


Next, we evaluated the 50%-threshold of POCP and POCPu to determine their reliability to delineate bacterial genera. This analysis was based on a broader range of genera to capture additional diversity: `r phyla_count_total_text`.
We included all the `r n_genomes` genomes and calculated POCP and POCPu for `r pairs_for_recommended` pairwise comparisons using the DIAMOND_VERYSENSITIVE method (@fig-pocp-pocpu-densities).

Instead of two bell-shaped distributions, with the 50% threshold separating between-genera POCPs (left) from within-genus POCPs (right), we observed overlapping POCP distributions (@fig-pocp-pocpu-densities A).
This was associated with a high number of false positives (FP = `r pocp_confusion["FP"]`), where between-genera values were >50%, especially compared with the number of true negatives (TN = `r pocp_confusion["TN"]`), where between-genera values were <50%.
Thankfully, most of the within-genus values were >50% (TP = `r pocp_confusion["TP"]`), with only few below the threshold (FN = `r pocp_confusion["FN"]`).

In contrast, POCPu was much closer to the expected results given the taxonomic assignments of each genome (@fig-pocp-pocpu-densities B).
Between-genera POCPu values followed a bi-modal distribution, with the highest peak and most of the distribution remaining below the 50%-threshold (TN = `r pocpu_confusion["TN"]`).
Nonetheless, a fraction of between-genera values spilled over the threshold, representing false positives, i.e., different genera when they are not  (FP = `r pocp_confusion["FP"]`).
As in the case of POCP, within-genus POCPu values were above the threshold of 50% (TP = `r pocpu_confusion["TP"]`), with a few below the threshold (FN = `r pocpu_confusion["FN"]`).
All in all, considering only unique protein matches improves genus delineation.


```{r mcc}
mcc_pocp <- targets::tar_read(mcc_pocp_global) %>%
  pull(mcc) %>% prettyNum(digits = 2)
mcc_pocpu <- targets::tar_read(mcc_pocpu_global) %>%
  pull(mcc) %>% prettyNum(digits = 2)
tally_mcc_thresholds <- summarise(
  tar_read(mcc_pocpu_family), 
  total = n(), n_70 = sum(mcc >= 0.7), n_25 = sum(mcc <= 0.25)
)
```

To quantify these findings on the confusion matrix (true/false positives and negatives), we used the Matthews Correlation Coefficient (MCC, @eq-mcc), which is a binary classification rate that gives a high score only when the classifier correctly predicts most of positive and negative cases.
POCPu (MCC = `r mcc_pocpu`) surpassed POCP (MCC = `r mcc_pocp`) to delineate bacterial genera, which quantitatively confirmed the visual findings (@fig-pocp-pocpu-densities).

::: {#fig-pocp-pocpu-densities}

```{r pocp-pocpu-densities}
tar_load(c(pocpu_group_sizes, pocp_range, pocpu_range))
knitr::include_graphics(tar_read(fig_pocp_pocpu_densities_png))
```

Distribution of POCP (A) and POCPu (B) values for all pairwise genome comparisons: `r pocpu_group_sizes[1]` in orange and `r pocpu_group_sizes[2]` in sky blue.
 The GTDB taxonomy was used as reference for the confusion matrix (true/false positives and negatives).
 POCP and POCPu values were calculated with our recommended method DIAMOND_VERYSENSITIVE  (@tbl-tools-parameters); they range from `r pocp_range` and `r pocpu_range`.
 The dashed lines indicate the standard 50% threshold for genus delineation.
:::

### Family-specific POCPu thresholds enable clearer genus delineation

```{r strepto_details}
strepto_details <- tar_read(pocpu_confusion_by_family) %>%
  filter(Family == "f__Streptomycetaceae") %>%
  mutate(p = proportions(n),
         p = scales::label_percent()(p),
         n = prettyNum(n,big.mark = ","),
         category=if_else(
           str_starts(class,"F"), "false cases", "true cases")
         ) %>%
  group_by(category) %>% nest() %>%
  mutate(
    foo = map(data, function(x){
      glue::glue_data(x,"{class} = {n} ({p})") %>% glue::glue_collapse(sep = " and ")
    })) %>% unnest(foo) %>%
  select(-data) %>% 
  deframe()
```


Analysing the bacterial families separately questioned the universal threshold of 50% conserved proteins (@fig-genus-delineation and @suppfig-pocpu-by-family).
The large family of _Streptomycetaceae_ (_Actinomycetota_), for instance, exhibited many false cases `r strepto_details["false cases"]`, despite even more true case `r strepto_details["true cases"]`, and consequently had a very low MCC (@fig-genus-delineation A).
In `r tally_mcc_thresholds[["n_25"]]` families out of 35, POCPu was clearly not adequate to delineate genus using a threshold of 50%, as indicated by low MCC (MCC $\leq$ 0.25; @fig-genus-delineation B).
In contrast, POCPu delineated bacterial genera accurately for `r tally_mcc_thresholds[["n_70"]]` families (MCC $\geq$ 0.7;  @fig-genus-delineation B).



::: {#fig-genus-delineation}

```{r genus-delineation}
knitr::include_graphics(tar_read(fig_genus_delineation_png))
```


POCPu delineates bacterial genera in a family-specific manner.
(A) Three representative examples of family-specific genus delineation capacity where POCPu values can (i) overlap and hamper genus delineation (top; example = _Streptomycetaceae_); (ii) be neatly distinct and allow for genus delineation (bottom; example =  _Xanthobacteraceae_); or (iii) any scenario in between (middle; example = _Lactobacillaceae_). The dashed lines indicate the standard threshold of 50% conserved proteins.
(B) The ability of POCPu to delineate genera was quantified for each of the 35 families analysed using the Matthews Correlation Coefficient [MCC, @chiccoAdvantagesMatthewsCorrelation2020].
An MCC of -1 and +1 indicates perfect misclassification or classification, respectively; random genus delineation corresponds to MCC = 0. The dashed line indicates the global MCC on the whole dataset, across all families. The number of genomes included per family are indicated in brackets next to the family names. The families were ranked per phyla (alphabetically; vertical facets in grey) and then by decreasing MCC within each phylum. The visual POCPu distributions for all families are provided in @suppfig-pocpu-by-family.
:::


```{r}
optimized_pocpu <- tar_read(optimized_pocpu) %>%
  filter(improved_classification) %>%
  mutate(
    rescued = if_else(mcc <0.7 & maximum_mcc>0.7,"rescued","improved"),
    category = if_else(optimized_threshold <= 50, "decrease","increase")
         ) 
n_tentative <- optimized_pocpu %>% count(rescued) %>% deframe()
n_category <- optimized_pocpu %>% count(category) %>% deframe()
improved_families <- optimized_pocpu %>%
    filter(rescued=="improved") %>%
    mutate(across(Phylum:Family, ~ str_remove(.x, "[p|f]__"))) %>%
  group_by(Phylum) %>%
  summarise(
    fam = glue::glue("_{Family}_") %>%
      glue::glue_collapse(", ", last = " and ")
    ) %>%
  glue::glue_data("{Phylum}: {fam}") %>%
  glue::glue_collapse("; ", last = "")

rescued_families <- optimized_pocpu %>%
    filter(rescued=="rescued") %>%
    mutate(across(Phylum:Family, ~ str_remove(.x, "[p|f]__"))) %>%
  group_by(Phylum) %>%
  summarise(
    fam = glue::glue("_{Family}_") %>%
      glue::glue_collapse(", ", last = " and ")
    ) %>%
  glue::glue_data("{Phylum}: {fam}") %>%
  glue::glue_collapse("; ", last = "")

decrease_family<- optimized_pocpu %>%
  filter(category=="decrease") %>%
    mutate(across(Phylum:Family, ~ str_remove(.x, "[p|f]__"))) %>%
  glue::glue_data("{p}% for _{Family}_ (_{Phylum}_)",
                  p = prettyNum(optimized_threshold, digits = 3)) %>%
  glue::glue_collapse(" and ")
```


Due to these differences between families, we looked for family-specific POCPu thresholds by maximizing MCC to improve genus delineation (@suppfig-pocpu-by-family and @tbl-optimized_threshold).
With this procedure, thresholds other than the default 50% would enhance classification for `r sum(n_tentative)` families out of the `r sum(stats_by_type$n_families)` families.
The genus delineation of `r n_tentative[["improved"]]` families was improved, with at least 0.1-point increase in MCC (white squares in @tbl-optimized_threshold; `r improved_families`).
For `r n_tentative[["rescued"]]` additional families  maximum MCC above 0.7 were even obtained (black squares in @tbl-optimized_threshold; `r rescued_families`).
Interestingly, in `r n_category[["decrease"]]` cases, the optimal POCPu threshold was lower than the standard threshold: `r decrease_family`.
In  `r n_category[["increase"]]` cases, new thresholds higher than 50% conserved proteins better separated genomes from within genus and between genera (@tbl-optimized_threshold).

Because POCP was previously proposed to be influenced by genome size [@riescoUpdateProposedMinimal2024], we used the large pairwise comparisons dataset to assess whether the changes in threshold were linked to differences in genome size.
If POCPu is influenced, we reasoned that its genus delineation power should also be influenced, therefore we expected stronger genome size differences in the families for which an alternative POCPu threshold was found.
We found no evidence that POCPu is affected by differences in genome size (@suppfig-delta A) nor proteins number (@suppfig-delta B).

::: {#tbl-optimized_threshold}


```{r optimized_threshold}
#| html-table-processing: none
#| classes: plain
tar_read(optimized_pocpu_table)
```

Proposal of family-specific POCPu thresholds for genus delineation. The thresholds were obtained after maximizing the MCC value to separate between-genera from within-genera distributions.
Squares indicate that MCC value change was greater than 0.1 with the optimized threshold, filled squares denote rescued families from MCC < 0.7 to MCC > 0.7, whilst empty squares indicate improved genus delineation.
Arrows highlight potential family-specific threshold worth considering to replace the default of 50% with the direction of change.
Families without squares already delineate genera correctly with the default of 50%.
:::


::: {#suppfig-pocpu-by-family}

```{r suppfigpocpu-by-family}
knitr::include_graphics(tar_read(fig_pocpu_by_family_png))
```

Distributions of POCPu values as in @fig-pocp-pocpu-densities broken down per bacterial family. The true category is based on the GTDB taxonomy.
The family-specific POCPu thresholds for genus delineation proposed in this study were taken from @tbl-optimized_threshold and are indicated with plain vertical line, whilst the default POCPu threshold of 50% is indicated by dashed lines.
:::


::: {#suppfig-delta}

```{r suppfigdelta}
knitr::include_graphics(tar_read(fig_delta_proteome_genome_png))
```

Distributions of differences in genome size (A) and proteome size (B) for families using default threshold or optimized thresholds. In case of an association between genome (or proteome) size and POCPu, we expected families for which optimized thresholds are proposed to have a shift towards larger differences explaining poor delineation performance in @fig-genus-delineation B. This was not the case, indicating that genome size and proteome size did not influence genus delineation. POCPu thresholds type were taken from  @tbl-optimized_threshold.
:::

# Discussion

```{r stats_total}
total_stats <- stats_by_type %>% 
  summarise(across(!benchmark_type,sum)) %>% 
  mutate(
    total_hours = round(total_hours),
    total_years = as.period(total_hours, unit = "hours") %>% as.numeric("years")
  ) %>% mutate(across(everything(), ~prettyNum(.x,big.mark = ",", digits=2)))
n_genera <- tar_read(genome_metadata) %>% pull(Genus) %>% n_distinct()
```


Qin et al. @qinProposedGenusBoundary2014 proposed to separate bacterial genera using the Percentage of Conserved Proteins (POCP) in genomes more than 10 years ago.
The descriptions of many novel genera note POCP values oscillating around the proposed threshold value of 50%, suggesting it is not a clear-cut separation [@afrizalEnhancedCulturedDiversity2022; @hitchBroadDiversityHuman2024; @wylensekCollectionBacterialIsolates2020].
We therefore set out to re-evaluate genus-level delineation based on POCP using a comprehensive dataset, and to develop a faster and clearer method.
<!-- We did this using a diverse collection of `r total_stats$n_genomes` genomes from `r n_genera` genera across `r total_stats$n_families` families and 4 phyla, resulting in `r total_stats$n_realized` unique genome pair combinations, with a total running time of `r total_stats$total_hours` CPU-Hours (`r total_stats$total_years` years). -->
We show that DIAMOND_VERYSENSITIVE can reliably replace BLASTP, speeding up the computing process by 20x.
In addition, we addressed an assumption made in previous POCP implementations [@holzerHoelzerPocp2020; @holzerPOCPnfAutomaticNextflow2024; @linSilentGeneBiopyBiopy2021], and thereby clearly defined an alternative POCP metric -- POCPu -- that uses only unique matches, thereby making genus delineation more accurate.

Genus names occur before species names in the binomial nomenclature of bacteria, and are therefore an important first contact with bacterial entities. They are key to existing knowledge in databases or articles and provide intuitive information on the evolutionary history and ecological roles of the organisms under study [@reimerBacDive2022Knowledge2022; @rosonovskiEuropePMC20232024; @schochNCBITaxonomyComprehensive2020].
The system works best when resources and tools follow FAIR principles [e.g., <https://nfdi4microbiota.de>, @wilkinsonFAIRGuidingPrinciples2016a], as done in this work.
We demonstrated that not all tools and parameters are suitable to speed up BLASTP; some combinations, whilst extremely fast, under- or overestimate POCP values, resulting in erroneous splitting or merging of genera.
While our analysis included phylogenomically diverse taxa, it was limited to the taxa within GTDB [@parksCompleteDomaintospeciesTaxonomy2020; @parksGTDBOngoingCensus2022] and focused on the dominant bacterial fraction. Despite the comprehensive nature of GTDB, our final genome selection might have missed important taxonomic groups of interest to readers. However, filtering the studied taxa was necessary to obtain enough data points per taxa to ensure statistical robustness. Previous studies on many-vs-many proteins alignment comparison used less phylogenetic diversity: 4 genomes from 4 genera in @hernandez-salmeronProgressQuicklyFinding2020, maximum 167 genomes from 5 genera in @holzerPOCPnfAutomaticNextflow2024.
Riesco et al. @riescoUpdateProposedMinimal2024 evaluated much more genomes -- 1,573 type strains -- but calculated POCP -- using Bio-Py [@linSilentGeneBiopyBiopy2021] -- only to be compared with AAI and not to evaluate genus delineation.

Threshold-based approaches are always a matter of compromise, and do not provide one-size-fits-all solution. Regarding species delineation, Parks et al. stated: "The use of ANI to delineate species despite the lack of clear evidence for discrete species boundaries in the GTDB dataset is a pragmatic approach for organizing the rapidly growing biodiversity being discovered with metagenomic approaches" @parksGTDBOngoingCensus2022.
We share their vision and propose the use of POCPu as an interpretable and pragmatic approach to delineate bacterial genera. In an effort to improve this process, we suggest refining the classification by applying family-specific POCPu thresholds, as shown previously for _Rhizobiaceae_ [@kuzmanovicTaxonomyRhizobiaceaeRevisited2022].
However, one should only deviate from the standard threshold of 50% if the benefit is greater than the risk of creating more confusion. We have provided tentative thresholds for several families, for which confidence was high. Finally, it is important to remember that accurate taxonomic placement is best achieved when multiple lines of evidence are considered, as implemented in Protologger [@hitchAutomatedAnalysisGenomic2021].
In the case of genera, POCPu decisions can be supported, for example by assessing the topology of phylogenetic trees, considering 16S rRNA gene identities [@yarzaUnitingClassificationCultured2014], and the result of GTDB-Tk analysis [@chaumeilGTDBTkV2Memory2022].

# Data availability

All the proteins sequences used in the analysis were downloaded from the GTDB (r214): <https://data.gtdb.ecogenomic.org/releases/release214/214.0/genomic_files_reps/gtdb_proteins_aa_reps_r214.tar.gz>, along with the associated metadata: <https://data.gtdb.ecogenomic.org/releases/release214/214.0/bac120_metadata_r214.tar.gz>. The list of valid bacteria names was obtained from: <https://github.com/thh32/Protologger/blob/0731adf80f1bbc5f8ee1904c8e9648ef45b13303/DSMZ-latest.tab>.
Raw output files from the workflow are deposited at <https://doi.org/10.5281/zenodo.14974869>. Cleaned and formatted POCP/POCPu values and metadata tables for analysis are deposited at <https://doi.org/10.5281/zenodo.14975029>.


# Code availability

The Nextflow workflow used for the benchmark is available at <https://github.com/ClavelLab/pocpbenchmark>. Code for the analyses, figures and manuscript is available at <https://github.com/ClavelLab/pocpbenchmark_manuscript>.

# Funding

TC received funding from the German Research Foundation (DFG): project no. 460129525 (NFDI4Microbiota), and project no. 445552570.

# Acknowledgments

The authors are grateful to Christian Schudoma, Daniel Podlesny and Mahdi Robbani for their help in fixing issues with an earlier version of the Nextflow workflow.
CP thanks all members of the Clavel Lab for constructive feedback on the figures at the lab retreat 2024.

# References

::: {#refs}
:::
